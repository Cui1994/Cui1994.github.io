<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>awakeBird</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 28 Nov 2018 00:04:13 +0800</pubDate>
    <lastBuildDate>Wed, 28 Nov 2018 00:04:13 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>你真的了解SQLAlchemy吗</title>
        <description>
</description>
        <pubDate>Tue, 27 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/27/sqlalchemy/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/27/sqlalchemy/</guid>
        
        <category>Python</category>
        
        <category>SQLAlchemy</category>
        
        <category>MySQL</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Zookeeper全攻略</title>
        <description>
&lt;img src=&quot;https://i.loli.net/2018/11/26/5bfc089b99acb.png&quot; alt=&quot;&quot; /&gt;

</description>
        <pubDate>Fri, 12 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/12/zookeeper/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/12/zookeeper/</guid>
        
        <category>Zookeeper</category>
        
        <category>学习实战</category>
        
        
        <category>Zookeeper</category>
        
      </item>
    
      <item>
        <title>使用pkgen生成唯一id的问题</title>
        <description>之前项目中有通过pkgen生成唯一id作为token字符串使用，一直未发现问题。

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PkGen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pkgen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

直到前些天在测试环境（服务器为阿里云）突然开始抛出异常。

</description>
        <pubDate>Sun, 09 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/09/pkgen/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/09/pkgen/</guid>
        
        <category>Python</category>
        
        <category>排坑</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Linux基础（二）文件系统及文件I/O</title>
        <description>
理解Linux文件系统的关键一点在于&lt;strong&gt;一切皆文件&lt;/strong&gt;的思想。

Linux中，文件既包括普通数据文件，又包括如设备、管道、套接字、目录、符号链接等特殊文件。

文件系统指的是常规文件和目录的组织集合，Linux支持多种文件系统，并提供虚拟文件系统（VFS）来隐藏不同文件系统的实现细节。

Linux内核维护了三种与文件相关的数据结构，也提供了一套通用的文件I/O模型对所有类型的文件进行操作。

&lt;blockquote&gt;
  该系列文章为《Linux/Unix系统编程手册》的学习笔记，由于该书太过冗长，属于工具书的类别，这里对书中的一些核心内容加以提炼和整理。
书中的编程练习这里不做展示和说明。
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 08 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/08/linux2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/08/linux2/</guid>
        
        <category>Linux</category>
        
        <category>读书笔记</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux基础（一）内核及系统调用</title>
        <description>
本文对Linux系统编程的一些基本概念做一些介绍，对应用程序系统调用的流程进行说明。

&lt;blockquote&gt;
  该系列文章为《Linux/Unix系统编程手册》的学习笔记，由于该书太过冗长，属于工具书的类别，这里对书中的一些核心内容加以提炼和整理。
书中的编程练习这里不做展示和说明。
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 16 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/16/linux/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/16/linux/</guid>
        
        <category>Linux</category>
        
        <category>读书笔记</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>大规模Web服务的一般性痛点与解决方案</title>
        <description>
如今，各类Web架构竞相辉映，集群，微服务，异地多活，分布式等名词层出不穷，这些东西是你日常工作的一部分，或者至少也是不少技术类文章中的热词，于开发人员来讲并不生疏。但这些东西是怎么来的，为了解决什么样的问题，确是值得思索的命题。

其实，如今各类成熟的Web服务架构并非一蹴而就的，而是随着服务规模的不断增大而演化过来的。刚来时可能服务的用户并不多，业务线也很少，这时的应用程序、数据库、静态文件可能都在一台服务器上，代码能够正常运行即可满足要求。而随着用户量的增加，一台服务器就无法满足需求了，流量的上升导致访问速度越来越慢，数据量的增大导致储存空间的不足，这时候就会将应用程序、数据库和文件服务进行分离，分别放在三台服务器上。之后，随着规模进一步加大，越来越多的问题暴露出来：为了解决应用程序服务的压力，出现了代理服务器、集群和负载均衡的概念；为了解决数据库压力，出现了读写分离、缓存服务器和分布式数据库的概念；为了解决文件服务器的压力，出现了CDN加速的概念；为了应对冗杂的业务线，出现了微服务和职能划分的概念……服务架构也慢慢趋于成熟变成了现在的模样。

本文就简单介绍下大规模Web服务发展过程中出现的一般性问题和解决方案。

</description>
        <pubDate>Sun, 15 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/15/web/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/15/web/</guid>
        
        <category>服务架构</category>
        
        <category>MySQL</category>
        
        <category>页面缓存</category>
        
        <category>扩展</category>
        
        
        <category>服务架构</category>
        
      </item>
    
      <item>
        <title>Python Web 基础向（七）分布式锁</title>
        <description>
当多个线程同时操作共享的内存数据时，为了解决线程安全问题，各语言都引入并发锁来确保同一时间只有一个线程会操作共享内存。而现在的大规模互联网应用一般采用分布式和集群来提高后端服务性能，同一个服务可能在不同的机器或容器中都存在实例，多线程中的并发锁也失去了意义，这时就引入了分布式锁的概念，当然它们的目的是相同的，都是为了限制同一时间内一个资源只能被一个请求操作，或者说某个方法只能被运行一次。

目前业内实现分布式锁的方式主要有下面三种：

&lt;ul&gt;
  &lt;li&gt;
    基于数据库的悲观锁乐观锁
  &lt;/li&gt;
  &lt;li&gt;
    基于redis的分布式事务锁
  &lt;/li&gt;
  &lt;li&gt;
    基于Zookeeper的节点锁
  &lt;/li&gt;
&lt;/ul&gt;

其中redis简单易用，应用最广也较为稳定，本文主要介绍这种方式下的分布式锁。

</description>
        <pubDate>Thu, 12 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/12/yewu7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/12/yewu7/</guid>
        
        <category>redis</category>
        
        <category>分布式锁</category>
        
        
        <category>Python Web</category>
        
      </item>
    
      <item>
        <title>Python Web 基础向（六） 查询</title>
        <description>
本篇文章将介绍实际业务中的查询场景。一般来说，这部分要做的只是从数据层调用查询方法获取数据并返回给api层。但在业务量不断上涨的过程中，可能会出现百万级以上的大规模数据查询场景，也可能会存在基础信息（用户账户信息等）被多个接口同时调用查询的场景，给DB造成很大压力。这时就需要考虑引入协程和缓存等方式来降低数据库IO。除此之外，还将介绍一些查询中经常碰到的一些场景的处理方法。

&lt;img src=&quot;https://i.loli.net/2018/11/26/5bfc04705c3ce.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;

</description>
        <pubDate>Fri, 20 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/20/yewu6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/20/yewu6/</guid>
        
        <category>ORM</category>
        
        <category>缓存</category>
        
        
        <category>Python Web</category>
        
      </item>
    
      <item>
        <title>Python Web 基础向（五） api层</title>
        <description>
提供HTTP服务的api层负责处理以下任务：
&lt;ul&gt;
  &lt;li&gt;管理路由&lt;/li&gt;
  &lt;li&gt;获取并检查参数&lt;/li&gt;
  &lt;li&gt;将请求分发给相应的逻辑层 (简单的函数调用，略)&lt;/li&gt;
  &lt;li&gt;包装返回数据&lt;/li&gt;
  &lt;li&gt;处理错误&lt;/li&gt;
&lt;/ul&gt;

api层的代码应简单清晰，甚至你的每个路由对应的函数都“长得”差不多，这部分代码不应掺杂任何逻辑处理，他要做的仅仅是将请求指向相应的逻辑类去处理。

</description>
        <pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/07/yewu5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/07/yewu5/</guid>
        
        <category>Flask</category>
        
        <category>降级策略</category>
        
        
        <category>Python Web</category>
        
      </item>
    
      <item>
        <title>Python Web 基础向（四） 浅谈数据层</title>
        <description>数据层一般会给人带来一些困扰，在于其定位不准确。聚合Model的工作也可以放在逻辑层做，但会导致逻辑层变重，经常出现大段晦涩代码。因此我的建议是保留Model聚合层，尽管会导致工作量的略微增加，但却可以使代码逻辑更加清晰，即每一层都只做自己该做的事。

&lt;img src=&quot;https://i.loli.net/2018/11/26/5bfc03f48a354.jpg&quot; alt=&quot;&quot; /&gt;

</description>
        <pubDate>Sat, 24 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/24/yewu4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/24/yewu4/</guid>
        
        
        <category>Python Web</category>
        
      </item>
    
  </channel>
</rss>
