<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="http://cuijintao.github.io/atom.xml" rel="self"/>
 <link href="http://cuijintao.github.io"/>
 <updated>2017-10-10T08:06:26-07:00</updated>
 <author>
   <name>崔金涛</name>
   <email>269584357@qq.com</email>
 </author>

 
 <entry>
   <title>为Spring Boot添加日志模块</title>
   <link href="http://cuijintao.github.io/posts/log.html"/>
   <updated>2017-06-29T00:00:00-07:00</updated>
   <id>/posts/log</id>
   <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。&lt;/p&gt;

&lt;p&gt;Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。&lt;/p&gt;

&lt;p&gt;默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。&lt;/p&gt;

&lt;h1 id=&quot;配置&quot;&gt;配置&lt;/h1&gt;

&lt;h2 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h2&gt;

&lt;p&gt;一般来说需要添加spring-boot-starter-logging：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际开发并不需要直接添加依赖，spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;自定义日志配置&quot;&gt;自定义日志配置&lt;/h2&gt;

&lt;p&gt;添加好依赖后原则上讲就可以开始使用日志模块了，但使用的是Spring Boot提供的很多默认配置，在&lt;code&gt;application.properties&lt;/code&gt;中也只能修改部分属性，往往不能满足需求，因此需要自行定制配置文件实现日志配置。&lt;/p&gt;

&lt;p&gt;Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;src/main/resources&lt;/code&gt;路径下添加&lt;code&gt;logback-spring.xml&lt;/code&gt;作为日志配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&amp;gt;
    &amp;lt;contextName&amp;gt;logback&amp;lt;/contextName&amp;gt;
    &amp;lt;property name=&quot;log.path&quot; value=&quot;C:\\Users\\cuijintao\\logback.log&quot; /&amp;gt;
    &amp;lt;!--输出到控制台--&amp;gt;
    &amp;lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--输出到文件--&amp;gt;
    &amp;lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;file&amp;gt;${log.path}&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxHistory&amp;gt;20&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;1GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&quot;info&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;console&quot; /&amp;gt;
        &amp;lt;appender-ref ref=&quot;file&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;

    &amp;lt;!-- logback为java中的包 --&amp;gt;
    &amp;lt;logger name=&quot;com.example.demo&quot;/&amp;gt;
    &amp;lt;!--logback.LogbackDemo：类的全路径 --&amp;gt;
    &amp;lt;logger name=&quot;com.example.hello&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;file&quot;/&amp;gt;
    &amp;lt;/logger&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;根节点configuration属性&quot;&gt;根节点&lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt;属性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。&lt;/li&gt;
  &lt;li&gt;scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。&lt;/li&gt;
  &lt;li&gt;debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;属性1---上下文名称contextname&quot;&gt;属性1 - 上下文名称&lt;code&gt;&amp;lt;contextName&amp;gt;&lt;/code&gt;:&lt;/h4&gt;
&lt;p&gt;每个logger都关联到logger上下文，默认上下文名称为“default”。
之后可以通过%contextName来打印日志上下文名称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;contextName&amp;gt;logback&amp;lt;/contextName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;属性2---属性变量property&quot;&gt;属性2 - 属性变量&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;定义一个key-value键值对
通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;property name=&quot;log.path&quot; value=&quot;C:\\Users\\cuijintao\\logback.log&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;子节点1---appender&quot;&gt;子节点1 - &lt;code&gt;&amp;lt;appender&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;encoder&amp;gt;&lt;/code&gt;表示对日志进行编码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;%d{HH: mm:ss.SSS}&lt;/code&gt; : 日志输出时间&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%thread&lt;/code&gt; : 日志输出进程名字&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%-5level&lt;/code&gt;: 日志级别 TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%logger{36}&lt;/code&gt; : 日志输出者名字&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%msg&lt;/code&gt;: 日志消息&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%n&lt;/code&gt;:　平台换行符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出到文件时，RollingFileAppender用于切分文件日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;!--输出到文件--&amp;gt;
    &amp;lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;file&amp;gt;${log.path}&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxHistory&amp;gt;20&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;1GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/code&gt;: 指定日志的切分方式&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;maxHistory&amp;gt;&lt;/code&gt;: 指定保留的切分文件的个数&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;totalSizeCap&amp;gt;&lt;/code&gt;: 指定日志文件的上限大小，超过此值将会被删除&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;子节点2---root&quot;&gt;子节点2 - &lt;code&gt;&amp;lt;root&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;必选节点，用来指定最基础的日志输出级别，只有一个level属性。
默认值为DEBUG.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;root level=&quot;debug&quot;&amp;gt;
  &amp;lt;appender-ref ref=&quot;console&quot; /&amp;gt;
  &amp;lt;appender-ref ref=&quot;file&quot; /&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;子节点3---loger&quot;&gt;子节点3 - &lt;code&gt;&amp;lt;loger&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;loger&amp;gt;&lt;/code&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;code&gt;&amp;lt;appender&amp;gt;&lt;/code&gt;。
仅有一个name属性，一个可选的level和一个可选的addtivity属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: 用来指定受此loger约束的某一个包或者具体的某一个类。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;level&lt;/code&gt;: 日志级别&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;addtivity&lt;/code&gt;: 是否向上级loger传递打印信息。默认是true。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;多环境日志输出&quot;&gt;多环境日志输出&lt;/h4&gt;
&lt;p&gt;据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&amp;gt;
&amp;lt;springProfile name=&quot;test,dev&quot;&amp;gt;
    &amp;lt;logger name=&quot;com.dudu.controller&quot; level=&quot;info&quot; /&amp;gt;
&amp;lt;/springProfile&amp;gt;
&amp;lt;!-- 生产环境. --&amp;gt;
&amp;lt;springProfile name=&quot;prod&quot;&amp;gt;
    &amp;lt;logger name=&quot;com.dudu.controller&quot; level=&quot;ERROR&quot; /&amp;gt;
&amp;lt;/springProfile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在启动或打包服务是配置profile参数即可。
如启动时指定prod的方式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar xxx.jar --spring.profiles.active=prod
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;demo&quot;&gt;demo&lt;/h1&gt;
&lt;p&gt;这里启动一个hello world的spring-boot模板来测试日志配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.example.demo.com.example.demo.hello;

import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class HelloController {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @RequestMapping(&quot;/hello&quot;)
    public String index() {

        logger.info(&quot;日志测试 info&quot;);
        logger.debug(&quot;日志测试 debug&quot;);

        return &quot;Hello World&quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上面的配置，日志文件中只记录了INFO级别的日志，每分钟对日志文件进行了切分。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>通过MULE实现后端服务调用</title>
   <link href="http://cuijintao.github.io/posts/mule.html"/>
   <updated>2017-06-28T00:00:00-07:00</updated>
   <id>/posts/mule</id>
   <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;h2 id=&quot;1简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;Mule ESB是一个基于Java的轻量级企业服务总线和集成平台，允许开发人员快速便利地连接多个应用，并支持应用间的数据交换。Mule ESB支持集成现有系统而无论其底层采用何种技术，如JMS、Web Services、JDBC、HTTP以及其他技术。&lt;/p&gt;

&lt;h2 id=&quot;2整体结构&quot;&gt;2.整体结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://my.oschina.net/uploads/space/2010/1206/131219_BfeJ_49921.jpg&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
Mule通过Transports/Connectors与外围的异构系统连接，提供Routing（路由）、Transaction Management（事务管理）、Transformation（转换）、Message Broker（消息代理）、Transportation Management（传输管理）、Security（安全）等核心模块。Mule可以单独使用，也可以架设在常用的应用服务器上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://my.oschina.net/uploads/space/2010/1206/104036_uBGk_49921.jpg&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
外围系统的服务请求通过Mule ESB的Transport接入，Mule通过Transformer进行数据的格式转换，然后经过Inbound Router进行消息过滤（内部通过配置filter实现）后交给Mule的Component进行业务逻辑处理，处理后的结果通过Outbound Router确定传递给哪个接收方，然后通过Transformer进行数据格式转换，通过Transport连接至接收方，传递信息。&lt;/p&gt;

&lt;p&gt;此图描述的是Mule中的一个典型场景的处理过程，涵盖了Mule中的各个关键组件。其中某些处理步骤不是必须的，如Inbound Router、Transformer。&lt;/p&gt;

&lt;h2 id=&quot;3功能&quot;&gt;3.功能&lt;/h2&gt;
&lt;h3 id=&quot;服务中介&quot;&gt;服务中介&lt;/h3&gt;

&lt;p&gt;将业务逻辑和消息发送分离
屏蔽服务的消息格式和协议
提供任意位置的服务调用
提供协议桥接&lt;/p&gt;

&lt;h3 id=&quot;数据转换&quot;&gt;数据转换&lt;/h3&gt;

&lt;p&gt;在应用间交换不同格式的信息 
操作消息的负载内容，包括加密、压缩和编码转换
在异构的传输协议的数据类型间格式化消息&lt;/p&gt;

&lt;h3 id=&quot;消息路由&quot;&gt;消息路由&lt;/h3&gt;

&lt;p&gt;基于消息内容和复杂规则路由消息
消息的过滤、聚合以及重新排列序号&lt;/p&gt;

&lt;h3 id=&quot;服务创建和托管&quot;&gt;服务创建和托管&lt;/h3&gt;

&lt;p&gt;暴露端点、EJB、Spring Bean以及POJO作为服务
作为轻量级的服务容器进行服务托管&lt;/p&gt;

&lt;h1 id=&quot;mule的基本元素&quot;&gt;Mule的基本元素&lt;/h1&gt;
&lt;h2 id=&quot;1flow&quot;&gt;1.Flow&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;&amp;lt;flow&amp;gt;&lt;/code&gt;元素在mule中配置Flow，Flow有一个name，消息源(一般由flow中定义的特定元素生成)和异常属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;flow name=&quot;&quot;&amp;gt;
    - 0..1 MessageSource
    - 1..n MessageProcessor(s)
    - 0..1 ExceptionStrategy
&amp;lt;/flow&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;消息源接收或生成消息时，一个Flow将被启动，并根据Flow中所配置好的元素顺序进行执行。
特别的，当Flow为Request-Response模型时，Flow中最后一个消息处理器的处理结果作为相应返回，也可以在Flow中定义Response元素来处理相应。&lt;/p&gt;

&lt;h2 id=&quot;2message&quot;&gt;2.Message&lt;/h2&gt;
&lt;p&gt;Message负责在Mule中的数据传递，在Mule中主要存在三种Message形式。&lt;/p&gt;

&lt;h3 id=&quot;property&quot;&gt;Property&lt;/h3&gt;
&lt;p&gt;属性，键值对形式，分为入站和出站属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;入站属性(Inbound properties)不可变，由消息源直接生成。
    &lt;pre&gt;&lt;code&gt;#[message.inboundProperties]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;出站属性(Outbound properties)可变，并可在流程中修改。
    &lt;pre&gt;&lt;code&gt;#[message.outboundProperties]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;variables&quot;&gt;Variables&lt;/h3&gt;
&lt;p&gt;变量，完全由用户在流程内定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;流变量(Flow variables) 只在其所在的Flow中可以使用。
    &lt;pre&gt;&lt;code&gt;#[flowVars]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;会话变量(Session variables) 适用于程序内所有的Flow。
    &lt;pre&gt;&lt;code&gt;#[sessionVars]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;记录变量(Record variables) 仅适用于批量处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;payload&quot;&gt;Payload&lt;/h3&gt;
&lt;p&gt;参数传递，在Flow中流转的待处理参数，可以被修改和更改格式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#[payload]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Message可以引入特定Component进行设置。&lt;/p&gt;

&lt;h2 id=&quot;3connector&quot;&gt;3.Connector&lt;/h2&gt;
&lt;p&gt;连接器将Mule应用程序与第三方API和标准集成协议集成，从而提供访问Web服务和资源的方法。
使用Mule流中的连接器通过协议或使用API，发送和接收数据。&lt;/p&gt;

&lt;p&gt;目前业务中涉及的连接器主要有HTTP连接器和AMQP连接器，其余连接器若有需要再行补充。&lt;/p&gt;

&lt;p&gt;连接器的具体配置方法在下面业务场景中列出，配置好的连接器被储存在全局元素中，在任意的Flow中都可以引用并获得这个元素的实例。&lt;/p&gt;

&lt;h3 id=&quot;http-listener-connector&quot;&gt;HTTP-Listener-Connector&lt;/h3&gt;
&lt;p&gt;HTTP侦听器连接器提供了最实际的方式来监听HTTP请求。&lt;/p&gt;

&lt;p&gt;连接器可以被配置为接受任何请求，或只接受寻址到特定URI的请求。可以选择连接器接受的方法：GET，POST等&lt;/p&gt;

&lt;p&gt;请求body被传递到Flow作为的下一个元素的Payload放入Message，而Header，Query参数，URI参数和HTTP请求的其它元件被传递作为入站属性。这些属性可以从Message中访问。&lt;/p&gt;

&lt;p&gt;此连接器还可以使用HTTPS协议，并通过TLS对通信进行加密。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http:listener-config name=&quot;HTTP_Listener_Configuration&quot; host=&quot;localhost&quot; port=&quot;8081&quot; doc:name=&quot;HTTP Listener Configuration&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;http-request-connector&quot;&gt;HTTP-Request-Connector&lt;/h3&gt;
&lt;p&gt;HTTP请求连接器提供了消费外部HTTP服务的最实际的方法。发送HTTP请求时，您可以选择使用哪种方法（GET，POST等），并可能包含一个header，body，查询参数，表单参数和URI参数。然后响应由连接器接收，并传递给流中的下一个元素。&lt;/p&gt;

&lt;p&gt;该连接器还可以实现HTTPS协议，并通过TLS对通信进行加密，还可以通过基本身份验证，OAuth，NTLM或摘要来实现身份验证。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;http:request-config name=&quot;HTTP_Request_Configuration&quot; host=&quot;127.0.0.1&quot; port=&quot;5000&quot; doc:name=&quot;HTTP Request Configuration&quot; basePath=&quot;/&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;amqp-connector&quot;&gt;AMQP-Connector&lt;/h3&gt;
&lt;p&gt;高级消息队列协议（AMQP）是一种开放标准，用于定义在应用程序或组织之间传递业务消息的协议。
AMQP连接器是先前引入的AMQP结构之上的一种抽象：连接，通道，交换，队列和消息。&lt;/p&gt;

&lt;p&gt;连接器隐藏了低级概念，例如处理通道，但是对其封装的所有结构进行了大量的控制，从而允许您访问AMQP的丰富性，而无需对其API进行编码。&lt;/p&gt;

&lt;p&gt;主要部件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Connector： 建立与AMQP broker的联系，如rabbitmq，管理由使用此连接器的所有消费者或发布商共享的一组公共属性&lt;/li&gt;
  &lt;li&gt;inbound-endpoint： 消耗来自AMQP队列的消息，将消息存入Mule的Message中&lt;/li&gt;
  &lt;li&gt;outbound-endpoint： 从Mule Flow向AMQP交换机发布消息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;mule的几种适用场景&quot;&gt;Mule的几种适用场景&lt;/h1&gt;

&lt;h2 id=&quot;1一个经典的http转发模型&quot;&gt;1.一个经典的HTTP转发模型&lt;/h2&gt;

&lt;h3 id=&quot;基本部件&quot;&gt;基本部件&lt;/h3&gt;
&lt;p&gt;核心由三个部分组成：HTTP-Liten-Connector, HTTP-Request-Connector, Set-Payload-Component，也可在之中即加入Echo-Component用于在Console中输出消息。&lt;/p&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP-Listen配置：
General-&amp;gt;General Setting-&amp;gt;Connector Configuration-&amp;gt;edit 指定HOST, PORT和BASE PATH
General-&amp;gt;Basic Setting-&amp;gt;Path 指定路由，*可以为任意路由，(此处可以应用到rest转发)
General-&amp;gt;Response 中指定返回值(如配置Header实现跨域请求)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set-Payload配置:
General-&amp;gt;Setting-&amp;gt;value 指定请求body的值(原值传递&lt;code&gt;#[payload]&lt;/code&gt;)
General-&amp;gt;MIME Type Setting 指定请求body类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP-Request配置(大部分和Listen相似，只需增加请求类型):
General-&amp;gt;URL Settings-&amp;gt;Method&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;demo&quot;&gt;demo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;http:listener-config name=&quot;HTTP_Listener_Configuration&quot; host=&quot;localhost&quot; port=&quot;8081&quot; doc:name=&quot;HTTP Listener Configuration&quot;/&amp;gt;
    &amp;lt;http:request-config name=&quot;HTTP_Request_Configuration&quot; host=&quot;127.0.0.1&quot; port=&quot;5000&quot; doc:name=&quot;HTTP Request Configuration&quot; basePath=&quot;/&quot;/&amp;gt;
    &amp;lt;flow name=&quot;helloworldFlow&quot;&amp;gt;
        &amp;lt;http:listener config-ref=&quot;HTTP_Listener_Configuration&quot; path=&quot;test&quot; responseStreamingMode=&quot;ALWAYS&quot; doc:name=&quot;HTTP-Listen&quot;&amp;gt;
            &amp;lt;http:response-builder&amp;gt;
                &amp;lt;http:header headerName=&quot;Access-Control-Allow-Origin&quot; value=&quot;#[message.inboundProperties.'Access-Control-Allow-Origin']&quot;/&amp;gt;
            &amp;lt;/http:response-builder&amp;gt;
        &amp;lt;/http:listener&amp;gt;
        &amp;lt;echo-component doc:name=&quot;Echo&quot;/&amp;gt;
        &amp;lt;set-payload value=&quot;#[payload]&quot; encoding=&quot;UTF-8&quot; mimeType=&quot;application/json&quot; doc:name=&quot;Set Payload&quot;/&amp;gt;
        &amp;lt;http:request config-ref=&quot;HTTP_Request_Configuration&quot; path=&quot;test&quot; method=&quot;POST&quot; doc:name=&quot;HTTP-Request&quot;&amp;gt;
            &amp;lt;http:request-builder&amp;gt;
                &amp;lt;http:header headerName=&quot;Access-Control-Allow-Mthods&quot; value=&quot;#[message.inboundProperties.'Access-Control-Allow-Mthods']&quot;/&amp;gt;
                &amp;lt;http:header headerName=&quot;Cookie&quot; value=&quot;#[message.inboundProperties.'Cookie']&quot;/&amp;gt;
            &amp;lt;/http:request-builder&amp;gt;
        &amp;lt;/http:request&amp;gt;
    &amp;lt;/flow&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2一个经典的rabbitmq消息转发&quot;&gt;2.一个经典的Rabbitmq消息转发&lt;/h2&gt;

&lt;h3 id=&quot;基本部件-1&quot;&gt;基本部件&lt;/h3&gt;
&lt;p&gt;Http-Listen-Connector, AMQP-Connector。其中AMQP相关连接器需要自行安装引入，我这里采用第三方软件包形式安装，还可通过官方软件包和Maven进行引入。&lt;/p&gt;

&lt;h3 id=&quot;配置-1&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;以HTTP-Listen和AMQP-EndPoint组成，其中HTTP-Listen和上面配置相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AMQP配置
Reference-&amp;gt;Global Reference-&amp;gt;Connector Reference-&amp;gt;add 添加AMQP-Connector，Protoal全部采用默认值。
General-&amp;gt;Address Attribute 配置Exchange和Queue&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;demo-1&quot;&gt;demo&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;amqp:connector name=&quot;AMQP_0_9_Connector&quot; validateConnections=&quot;true&quot; doc:name=&quot;AMQP-0-9 Connector&quot;/&amp;gt;
    &amp;lt;http:listener-config name=&quot;HTTP_Listener_Configuration&quot; host=&quot;localhost&quot; port=&quot;8081&quot; doc:name=&quot;HTTP Listener Configuration&quot;/&amp;gt;
    &amp;lt;amqp:endpoint exchangeName=&quot;Kong&quot; queueName=&quot;hello&quot; name=&quot;AMQP_0_91&quot; responseTimeout=&quot;10000&quot; doc:name=&quot;AMQP-0-9&quot;/&amp;gt;
    &amp;lt;flow name=&quot;test4Flow&quot;&amp;gt;
        &amp;lt;http:listener config-ref=&quot;HTTP_Listener_Configuration&quot; path=&quot;/&quot; doc:name=&quot;HTTP&quot;/&amp;gt;
        &amp;lt;amqp:outbound-endpoint connector-ref=&quot;AMQP_0_9_Connector&quot; exchangeName=&quot;Kong&quot; doc:name=&quot;AMQP-0-9&quot; queueName=&quot;hello&quot; responseTimeout=&quot;10000&quot;/&amp;gt;
    &amp;lt;/flow&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3rest格式请求&quot;&gt;3.REST格式请求&lt;/h2&gt;

&lt;p&gt;大致与http格式相似，需要用到MULE表达式将HTTP-Listener中的path传递给HTTP-Request&lt;/p&gt;

&lt;h3 id=&quot;demo-2&quot;&gt;demo&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;http:listener-config name=&quot;HTTP_Listener_Configuration&quot; host=&quot;localhost&quot; port=&quot;8081&quot; doc:name=&quot;HTTP Listener Configuration&quot;/&amp;gt;
    &amp;lt;http:request-config name=&quot;HTTP_Request_Configuration&quot; host=&quot;localhost&quot; port=&quot;5000&quot; doc:name=&quot;HTTP Request Configuration&quot;/&amp;gt;
    &amp;lt;flow name=&quot;test5Flow&quot;&amp;gt;
        &amp;lt;http:listener config-ref=&quot;HTTP_Listener_Configuration&quot; path=&quot;/*&quot; doc:name=&quot;HTTP&quot;/&amp;gt;
        &amp;lt;http:request config-ref=&quot;HTTP_Request_Configuration&quot; path=&quot;#[message.inboundProperties.'http.request.path']&quot; method=&quot;GET&quot; doc:name=&quot;HTTP&quot;&amp;gt;
            &amp;lt;http:request-builder&amp;gt;
                &amp;lt;http:query-params expression=&quot;#[message.inboundProperties.'http.query.params']&quot;/&amp;gt;
            &amp;lt;/http:request-builder&amp;gt;
        &amp;lt;/http:request&amp;gt;
    &amp;lt;/flow&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>BPMN2.0概念</title>
   <link href="http://cuijintao.github.io/posts/bmpn.html"/>
   <updated>2017-06-13T00:00:00-07:00</updated>
   <id>/posts/bmpn</id>
   <content type="html">&lt;h2 id=&quot;1简介&quot;&gt;1.简介&lt;/h2&gt;

&lt;p&gt;BPMN（Business Process Model And Notation）- 业务流程模型和符号 是有BPMI（Business Process Management Initiative）开发的一套变准的业务流程建模符号。2004年5月发布了BPMN1.0规范.BPMI于2005年9月并入OMG（The Object Management Group)组织。OMG于2011年1月发布BPMI2.0的最终版本
![此处输入图片的描述][4]&lt;/p&gt;

&lt;h2 id=&quot;2规范&quot;&gt;2.规范&lt;/h2&gt;

&lt;h3 id=&quot;21-bpmn2-conformance-一致性&quot;&gt;2.1 BPMN2-Conformance 一致性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Process Modeling Conformance 流程模型一致性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process Execution conformance 流程执行一致性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BPEL Process Execution Conformance BPEL 流程执行一致性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Choreography Modeling Conformance 编排模型一致性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-bpmn2-element-元素&quot;&gt;2.2 BPMN2-Element 元素&lt;/h3&gt;
&lt;p&gt;![此处输入图片的描述][5]&lt;/p&gt;
&lt;h4 id=&quot;221-flow-objects-流对象&quot;&gt;2.2.1 Flow Objects 流对象&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Events 事件
![此处输入图片的描述][6]
Event 用一个圆圈表示，它是流程中运行过程中发生的事情。事件的发生会影响到流程的流转.事件包含Start\Intermediate\End三种类型.启动、结束、边界条件以及每个活动的创建、开始、流转等都是流程事件，利用事件机制，可以通过事件控制器为系统增加辅助功能，如其它业务系统集成、活动预警等.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activities 活动
![此处输入图片的描述][7]
活动用圆角矩形表示，一个活动多个活动组成，活动的类型分为Task和Sub-Process.     &lt;br /&gt;
Task能描述业务过程中所有能发生工时的行为，是流程在流转过程中的一个原子活动，它被用于流程中的工作不能被拆开到更细级别时的场景.
Sub-Process事件子过程可以出现在过程或子过程中，其开始事件触发它活动，它可以中断上一层过程，也可以与上一层过程中的活动平行执行，这一切取决于它开始事件的行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Gateways 网关
![此处输入图片的描述][8]
网关用菱形表示,用于控制流程的分支和聚合.决定流程流转指向.用来对流程中的决策进行建模。
(1)排他网关
(2)并行网关&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;222-data-数据&quot;&gt;2.2.2 Data 数据&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][9]
数据对象向读者显示在活动中需要或产生哪些数据.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Data Objects 数据对象
代表过程中流动的信息，例如：业务文件、E-mail、信件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data Inputs 数据输入
整个过程中可以被活动读取的外部数据.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data OutPuts 数据输出
作为整个过程的输出数据量.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data Stores 数据存储
存放过程数据的地方，例如数据库或文件。其生命周期超过了过程实例的生命周期，即过程实例结束了，但数据依然存在。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Message 消息
消息用来表示两个参与者之间通讯的内容。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;223-connecting-objects-连接对象&quot;&gt;2.2.3 Connecting Objects 连接对象&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][10]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Sequence Flows 序列流
Sequence Flows 用实线实心箭头表示，代表流程中将被执行的活动的执行顺序.
是两个流程元素间的连接器.一个元素在流程执行期间被访问后，流程会沿着该元素输出的方向继续执行.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Message Flows 消息流
Message Flows 用虚线空心箭头表示，第阿宝2个分开的流程参与者直接发送或者接收到的消息流.
消息流可以与泳池、活动或消息事件连在一起.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Associations 结合关系
Associations 用点状虚线表示，用于显示活动的输入输出.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data Associations 数据结合关系&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;224-swimlanes-泳道&quot;&gt;2.2.4 Swimlanes 泳道&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][11]
泳池和泳道都表示活动的参与者，即表示过程中活动的执行者，它可以是一个组织、角色或系统。泳池可以划分成多个泳道，泳道具有分层结构.
是从视觉上对活动加以组织或分类的机制。它基于交叉功能流程图基础，在BPMN中有两种类型.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pools 池
表示流程中的主要参与者，典型地，用来分开不同的组织。一个池可容纳一个或多个道（像真实的泳池一样）。当池为展开的（显示出内部细节），绘做大的矩形；若为收起的（隐藏起内部细节），绘做沿着图的长或宽伸展的空的矩形。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lanes 道
在池中，用于活动按职能或角色归类。绘做按池的长或宽展开的矩形。道包含流对象、连接对象和人造物。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;225-artifacts-工件&quot;&gt;2.2.5 Artifacts 工件&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][12]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Group 组&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Text Annotation 文本注释&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-流程&quot;&gt;2.3 流程&lt;/h3&gt;

&lt;h4 id=&quot;231-流程图&quot;&gt;2.3.1 流程图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;私有流程
指某一组织内部的流程，也叫工作流.在Web Service领域指服务的编制.&lt;/li&gt;
  &lt;li&gt;共有流程
表现为一个私有流程和其他流程或参与者之间的交互.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;232-协作图&quot;&gt;2.3.2 协作图&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][13]
描绘两个或多个业务实体之间的交互.&lt;/p&gt;

&lt;h4 id=&quot;233-编排图&quot;&gt;2.3.3 编排图&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][14]
表现多个参与者之间的交互，由编排活动直接表现多个参与者之间的消息交互，为协作模型提供了一种基于流程图的模型.&lt;/p&gt;

&lt;h4 id=&quot;234-会话图&quot;&gt;2.3.4 会话图&lt;/h4&gt;
&lt;p&gt;![此处输入图片的描述][15]
协作模型的另一种表现形式.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用flask_socketio实现与前段的socket通信</title>
   <link href="http://cuijintao.github.io/posts/socketio.html"/>
   <updated>2017-05-16T00:00:00-07:00</updated>
   <id>/posts/socketio</id>
   <content type="html">&lt;h2 id=&quot;demo&quot;&gt;Demo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;flask_socketio&lt;/code&gt;将&lt;code&gt;flask&lt;/code&gt;应用用socketio包装了一层，可以与web端实现websocket连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from flask import Flask, render_template
from flask_socketio import SocketIO, emit

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret'
socketio = SocketIO(app)

@app.route('/')
def index():
    return render_template('index.html')
    
@socketio.on('connect')
def client_msg():
    print 'connect!'
    
@socketio.on('connect with token')
def connect_with_token(message):
    token = message['token']
    emit('notification', {'msg': 'done!'})
    
    
if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0', port=5300)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/static/node_modules/socket.io-client/dist/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    function localConnectSocket(){
    var socket = io.connect('http://localhost:5300');
    socket.emit(&quot;connect with token&quot;, {'token': 'xxxx'});
    socket.on(&quot;notification&quot;, function (data) {
        alert(data.msg)
    });
    }
&amp;lt;/script&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;button type=&quot;button&quot; onclick=&quot;localConnectSocket()&quot;&amp;gt;localConnectSocket&amp;lt;/button&amp;gt;
    &amp;lt;br /&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;发送消息到特定连接&quot;&gt;发送消息到特定连接&lt;/h2&gt;
&lt;p&gt;每个连接有一个&lt;code&gt;sid&lt;/code&gt;，存在&lt;code&gt;request.sid&lt;/code&gt;中。
每个链接socketio会将其分配至一个以其&lt;code&gt;sid&lt;/code&gt;为名的&lt;code&gt;room&lt;/code&gt;中，据此可发送消息至每一个特定连接.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Object that represents a socket connection
class Socket:
    def __init__(self, sid):
        self.sid = sid
        self.connected = True

    # Emits data to a socket's unique room
    def emit(self, event, data):
        emit(event, data, room=self.sid)

@socketio.on('connect')
def foo():
    sockets[request.sid] = Socket(request.sid)
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>大话设计模式Python实现</title>
   <link href="http://cuijintao.github.io/posts/shejimoshi.html"/>
   <updated>2017-04-13T00:00:00-07:00</updated>
   <id>/posts/shejimoshi</id>
   <content type="html">&lt;p&gt;学习自大话设计模式，将其C#语言实现翻译为Python，同时参照此系列博客：&lt;a href=&quot;http://www.jianshu.com/p/84ae207ccaf7&quot;&gt;Python设计模式&lt;/a&gt; 加深理解。&lt;/p&gt;

&lt;h2 id=&quot;1简单工厂模式&quot;&gt;1.简单工厂模式&lt;/h2&gt;

&lt;p&gt;面向对象目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可维护：只需要改动需求制定功能的类或模块&lt;/li&gt;
  &lt;li&gt;可复用：可以用在不同的环境下&lt;/li&gt;
  &lt;li&gt;可扩展：增加功能只需要增加相应的模块&lt;/li&gt;
  &lt;li&gt;灵活性好：可以任意组合功能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;耦合性：更改一个功能不需要接触其他功能（即使功能都是相似的），考虑通过封装、继承和多态将耦合性降低。&lt;/p&gt;

&lt;p&gt;根据需求实例化要实例的对象（这些对象可能均继承自同一基类）。&lt;/p&gt;

&lt;p&gt;缺点：违反了高内聚职责分配原则 &lt;a href=&quot;http://www.cnblogs.com/sevenyuan/archive/2010/03/05/1678730.html&quot;&gt;职责分配原则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;计算器实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-
import re=

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a / self.b
		return result

class OperationFactory(object):
	def create_operation(self, operation, a, b):
		if operation == '+':
			return AddOperation(a, b)
		elif operation == '-':
			return SubtractOperation(a, b)
		elif operation == '*':
			return MultiplicationOperation(a, b)
		elif operation == '/':
			return DivisionOperation(a, b)
		else:
			raise ValueError

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][3]
		b = int(items[0][2])
		print OperationFactory().create_operation(operation, a, b).calculate_result()
	except:
		print 'Wrong Input.'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2策略模式&quot;&gt;2.策略模式&lt;/h2&gt;

&lt;p&gt;将一系列算法家族封装，算法家族完成的是同一类功能的不同实现（都是用来解决同一个问题的，只是不同情况需要应用不同的算法），降低了客户端和算法类之间的耦合。&lt;/p&gt;

&lt;p&gt;缺点：增加策略时仍然需要到&lt;code&gt;Context&lt;/code&gt;类中增加一个新的判断分支。&lt;/p&gt;

&lt;p&gt;超市活动实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class Strategy(object):
	# 抽象算法类
	def algorithm_interface(self):
		raise NotImplementedError()

class NormalStrategy(Strategy):

	def algorithm_interface(self, money):
		return money

class RebateStrategy(Strategy):

	def __init__(self, rebate):
		self.rebate = rebate

	def algorithm_interface(self, money):
		return money*self.rebate

class ReturnStrategy(Strategy):

	def __init__(self, each_money, return_money):
		self.each_money = each_money
		self.return_money = return_money

	def algorithm_interface(self, money):
		return money-(money/self.each_money)*self.return_money

class Context(object):
	# 上下文，封装策略的实现细节
	def __init__(self, strategy_type):
		if strategy_type == 'normal':
			self.strategy = NormalStrategy()
		elif strategy_type == '0.8 rebate':
			self.strategy = RebateStrategy(0.8)
		elif strategy_type == '300 return 100':
			self.strategy = ReturnStrategy(300, 100)

	def context_interface(self, money):
		return self.strategy.algorithm_interface(money)

if __name__ == '__main__':
	money = int(raw_input('Enter money:'))
	strategy_type = raw_input('Enter strategy type:')
	print Context(strategy_type).context_interface(money)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3单一职责原则&quot;&gt;3.单一职责原则&lt;/h2&gt;

&lt;p&gt;类的功能要尽量单一——利于解耦&lt;/p&gt;

&lt;h2 id=&quot;4开放封闭原则&quot;&gt;4.开放封闭原则&lt;/h2&gt;

&lt;p&gt;最扩展开放，最修改封闭。（写好的类尽量不要去改动他）
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
在最开始写代码时，假定变化不会发生，当变化发生之后，就要创建抽象来隔离变化。&lt;/p&gt;

&lt;h2 id=&quot;5依赖倒转原则&quot;&gt;5.依赖倒转原则&lt;/h2&gt;

&lt;p&gt;抽象不应该依赖于细节，细节应该依赖于抽象。
要对接口编程，而不要对实现编程。
里氏代换原则：子类必须能够替换掉他们的父类型。&lt;/p&gt;

&lt;h2 id=&quot;6装饰模式&quot;&gt;6.装饰模式&lt;/h2&gt;

&lt;p&gt;把每个需要装饰的功能放在单独的类中，需要使用新功能时只需要用装饰的类去包装原有的核心类，将类的核心职责和装饰功能分开，避免增加核心类的复杂度。&lt;/p&gt;

&lt;p&gt;python自带的装饰器也是一种装饰模式的实现。&lt;/p&gt;

&lt;p&gt;穿衣服实例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-
class Person(object):

	def __init__(self):
		self.name = ''

	def set_name(self, name):
		self.name = name

	def show(self):
		print u'装扮的{0}'.format(self.name)

class Finery(Person):

	def set_decorate(self, component):
		self.component = component

	def show(self):
		if self.component:
			self.component.show()

class TShirts(Finery):

	def show(self):
		print u'T-shirt.'
		super(TShirts, self).show()

class BigTrouser(Finery):

	def show(self):
		print u'Big-Trouser.'
		super(BigTrouser, self).show()

if __name__ == '__main__':
	xiao_ming = Person()
	xiao_ming.set_name('xiaoMing')

	print u'第一种装扮：'
	t_shirt = TShirts()
	big = BigTrouser()

	t_shirt.set_decorate(xiao_ming)
	big.set_decorate(t_shirt)

	big.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;7代理模式&quot;&gt;7.代理模式&lt;/h2&gt;

&lt;p&gt;用代理对象去调用真是对象的接口，可以完成一些额外的事。&lt;/p&gt;

&lt;p&gt;代理和真是对象公用一个接口（继承自同一基类）。代理此接口的真正目的是调用真实对象的接口。&lt;/p&gt;

&lt;p&gt;代码实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class Subject(object):

	def request(self):
		raise NotImplementedError

class RealSubject(Subject):

	def request(self):
		print 'Real Request.'

class ProxySubject(Subject):

	def __init__(self):
		self.real = RealSubject()

	def request(self):
		self.real.request()

if __name__ == '__main__':
	proxy = ProxySubject()
	proxy.request()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;8工厂方法模式&quot;&gt;8.工厂方法模式&lt;/h2&gt;

&lt;p&gt;将简单工厂模式实例化类的时机延后到工厂子类进行，克服了简单工厂模式违背封闭原则的缺点。&lt;/p&gt;

&lt;p&gt;但其仍有缺点：判断分支从工厂中转移到了客户端中进行。相当于绕了一圈又绕回来了。&lt;/p&gt;

&lt;p&gt;计算器实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-
import re

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a // self.b
		return result

class IFactory(object):
	def create_operation(self, a, b):
		raise NotImplementedError

class AddFactory(IFactory):
	def create_operation(self, a, b):
		return AddOperation(a, b)

class SubFactory(IFactory):
	def create_operation(self, a, b):
		return SubtractOperation(a, b)

class MulFactory(IFactory):
	def create_operation(self, a, b):
		return MultiplicationOperation(a, b)

class DivFactory(IFactory):
	def create_operation(self, a, b):
		return DivisionOperation(a, b)

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][1]
		b = int(items[0][2])
		if operation == '+':
			oper = AddFactory().create_operation(a, b)
		elif operation == '-':
			oper = SubFactory().create_operation(a, b)
		elif operation == '*':
			oper = MulFactory().create_operation(a, b)
		elif operation == '/':
			oper = DivFactory().create_operation(a, b)
		print oper.calculate_result()
	except:
		print 'Wrong Input.'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;9原型模式&quot;&gt;9.原型模式&lt;/h2&gt;

&lt;p&gt;从一个对象再创建一个可定制的对象，而且不需要知道任何创建的细节。（不需要再手动实例化一个新实例）
tip：这里涉及了深浅拷贝的概念。&lt;/p&gt;

&lt;p&gt;优点：隐藏创建细节，提高性能。（不需要每次都调用构造函数）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import copy

class Book(object):
	def __init__(self, name, authors, price):
		self.name = name
		self.authors = authors
		self.price = price

	def clone(self, **kwargs):
		book_copy = copy.deepcopy(self)
		book_copy.__dict__.update(**kwargs)
		return book_copy

book1 = Book('Python', ['Tom', 'Jack'], 10)
book2 = book1.clone(price=20)
print book2.__dict__
# {'price': 20, 'name': 'Python', 'authors': ['Tom', 'Jack']}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;10-模板方法模式&quot;&gt;10. 模板方法模式&lt;/h2&gt;

&lt;p&gt;比较常见的设计模式，制定一种工作流或算法的特定骨架而将具体实现放到子类中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class FatherClass(object):
    def tempmethod(self):
        print &quot;first step: red&quot;
        self.childmethod()
        print &quot;third step: blue&quot;
        
    def childmethod(self):
        raise NotImplementedError
    
class ChildClass1(FatherClass):
    def childmethod(self):
        print &quot;second step: green&quot;
        
class ChildClass2(FatherClass):
    def childmethod(self):
        print &quot;second step: yellow&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;11迪米特法则&quot;&gt;11.迪米特法则&lt;/h2&gt;

&lt;p&gt;如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类要调用另一个类的某一个方法，可以通过第三者转发这个调用。&lt;/p&gt;

&lt;p&gt;强调类之间的松耦合。耦合度越低，越利于复用。&lt;/p&gt;

&lt;h2 id=&quot;12外观模式&quot;&gt;12.外观模式&lt;/h2&gt;

&lt;p&gt;给一组系统方法一个统一的接口，提供了一个更高层的接口方法。&lt;/p&gt;

&lt;p&gt;有点类似代理模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class ModuleOne(object):
    def Create(self):
        print 'create module one instance'

    def Delete(self):
        print 'delete module one instance'

class ModuleTwo(object):
    def Create(self):
        print 'create module two instance'

    def Delete(self):
        print 'delete module two instance'

class Facade(object):
    def __init__(self):
        self.module_one = ModuleOne()
        self.module_two = ModuleTwo()

    def create_module_one(self):
        self.module_one.Create()

    def create_module_two(self):
        self.module_two.Create()

    def create_both(self):
        self.module_one.Create()
        self.module_two.Create()

    def delete_module_one(self):
        self.module_one.Delete()

    def delete_module_two(self):
        self.module_two.Delete()

    def delete_both(self):
        self.module_one.Delete()
        self.module_two.Delete()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;13建造者模式&quot;&gt;13.建造者模式&lt;/h2&gt;

&lt;p&gt;讲一个复杂对象的构建和他的表示分离，这样可以用同样的构建方式创建不同的表示。&lt;/p&gt;

&lt;p&gt;优点：对象内部的构建顺序是稳定的，建造者隐藏了产品如何组装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class Builder(object):
# 抽象建造者类，也可以说是产品类
	def part1(self):
		raise NotImplementedError

	def part2(self):
		raise NotImplementedError

class Builder1(object):

	def part1(self):
		print 'builder1 part1'

	def part2(self):
		print 'builder1 part2'

class Builder2(object):

	def part1(self):
		print 'builder2 part1'

	def part2(self):
		print 'builder2 part2'

class Director(object):

	def build(self, builder):
		builder.part1()
		builder.part2()

if __name__ == '__main__':
	builder = Builder1()
	director = Director()

	director.build(builder)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以将&lt;code&gt;Director&lt;/code&gt;的代码已到&lt;code&gt;Builder&lt;/code&gt;类中，实现模板方法模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Builder(object):
    # ···
    def build(self):
        self.part1()
        self.part2()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;14观察者模式&quot;&gt;14.观察者模式&lt;/h2&gt;

&lt;p&gt;又称作Pub/Sub模式
定义了一种一对多的依赖关系，让众多观察者可以同时关注某一主题，当主题发生变化时每个观察者都会更新自己的状态。
许多MQ都是通过这一模式实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Topic(object):

	def __init__(self):
		self.obs = []

	def attach(self, observer):
		self.obs.append(observer)

	def detach(self, observer):
		self.obj.remove(observer)

	def notify(self, message):
		for observer in self.obs:
			observer.update(message)

class Observer(object):

	def update(self, message):
		raise NotImplementedError

class ConcreteObserver(Observer):

	def update(self, message):
		print message

if __name__ == '__main__':
	topic = Topic()
	ob1 = ConcreteObserver()
	ob2 = ConcreteObserver()
	topic.attach(ob1)
	topic.attach(ob2)
	topic.notify(&quot;hello&quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;15抽象工厂模式&quot;&gt;15.抽象工厂模式&lt;/h2&gt;

&lt;p&gt;创建具有一定功能的产品实现时，需要先创建具体的工厂类，再由工厂类创建具有特定实现的产品对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class IUser(object):

	def insert_user(self, user):
		raise NotImplementedError

	def get_user(self, userid):
		raise NotImplementedError

class IRole(object):
	def insert_role(self, role):
		raise NotImplementedError

	def get_role(self, roleid):
		raise NotImplementedError

class SqlServerUser(IUser):

	def insert_user(self, user):
		print u&quot;在SQL Server中给User表增加一条记录.&quot;

	def get_user(self, userid):
		print u&quot;在SQL Server中拿到一条uer信息。&quot;

class SqlServerRole(IRole):
	def insert_role(self, role):
		print u&quot;在SQL Server中给Role表增加一条记录&quot;

	def get_role(self, roleid):
		print u&quot;在SQL Server中拿到一条role记录&quot;

# 产品类        
class AccessUser(IUser):
	def insert_user(self, user):
		print u&quot;在Access中给User表增加一条记录.&quot;

	def get_user(self, userid):
		print u&quot;在Access中拿到一条uer信息。&quot;

class AccessRole(IUser):
	def insert_role(self, role):
		print u&quot;在Access中给Role表增加一条记录&quot;

	def get_role(self, roleid):
		print u&quot;在Access中拿到一条role记录&quot;

# 抽象工厂类
class IFactory(object):
	def create_user(self):
		raise NotImplementedError

	def create_role(self):
		raise NotImplementedError

# 具体工厂类
class SqlServerFactory(IFactory):

	def create_user(self):
		return SqlServerUser()

	def create_role(self):
		return SqlServerRole()

# 具体工厂类
class AccessFactory(IFactory):

	def create_user(self):
		return AccessUser()

	def create_role(self):
		return AccessRole()

class User(object):

	def __init__(self, id):
		self.id = id

class Role(object):

	def __init(self, id):
		self.id = id


if __name__ == '__main__':

	user = User(1)
	factory = SqlServerFactory()
	iu = factory.create_user()

	iu.insert_user(user)
	iu.get_user(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以考虑用引入简单工厂加反射进行优化。&lt;/p&gt;

&lt;h2 id=&quot;16状态模式&quot;&gt;16.状态模式&lt;/h2&gt;

&lt;p&gt;对象的行为取决于它的状态，并且他需要在运行时刻根据状态改变它的行为。&lt;/p&gt;

&lt;p&gt;此时会产生大量判断语句，使用状态模式可以消除这些判断语句，降低耦合性。&lt;/p&gt;

&lt;p&gt;工作实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class State(object):
	def write_program(work):
		raise NotImplementedError

class ForenoonState(State):
	def write_program(self, wrok):
		if work.hour &amp;lt; 12:
			print u&quot;当前时间: {}点， 上午工作，精神百倍&quot;.format(work.hour)
		else:
			wrok.set_state(NoonState())
			work.write_program()

class NoonState(State):
	def write_program(self, work):
		if work.hour &amp;lt; 13:
			print u&quot;当前时间：{}点， 饿了，午饭； 困了，午休&quot;.format(work.hour)
		else:
			work.set_state(AfternoonState())
			work.write_program()

class AfternoonState(State):
	def write_program(self, work):
		if work.task_finished:
			work.set_state(RestState())
		if work.hour &amp;lt; 17:
			print u&quot;当前时间：{}点， 下午状态不错，继续努力&quot;.format(work.hour)
		else:
			work.set_state(EveningState())
			work.write_program()

class EveningState(State):
	def write_program(self, work):
		print u&quot;当前时间： {}点， 又要加班了！&quot;.format(work.hour)

class RestState(State):
	def write_program(self, work):
		print u&quot;当前时间： {}点， 下班回家啦&quot;.format(work.hour)

class Work(object):
	def __init__(self):
		self.current = ForenoonState()
		self.hour = 9
		self.task_finished = False

	def set_hour(self, hour):
		self.hour = hour

	def set_finished(self, finished):
		self.set_finished = finished

	def set_state(self, state):
		self.current = state

	def write_program(self):
		self.current.write_program(self)

if __name__ == &quot;__main__&quot;:
	work = Work()
	work.set_hour(9)
	work.write_program()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;17适配器模式&quot;&gt;17.适配器模式&lt;/h2&gt;

&lt;p&gt;当一个类的功能和数据相同而接口不同时，需要适配器模式充当翻译角色。&lt;/p&gt;

&lt;p&gt;缺点：亡羊补牢&lt;/p&gt;

&lt;p&gt;NBA翻译实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# -*- coding:utf-8 -*-

class Player(object):
	def __init__(self, name):
		self.name = name

	def attack(self):
		print u&quot;{} 进攻&quot;.format(self.name)

	def defense(self):
		print u&quot;{} 防守&quot;.format(self.name)

class ForeignPlayer(object):

	def __init__(self, name):
		self.name = name

	def jingong(self):
		print u&quot;{} 进攻&quot;.format(self.name)

	def fangshou(self):
		print u&quot;{} 防守&quot;.format(self.name)

class Translator(Player):

	def __init__(self, name):
		super(Translator, self).__init__(name)
		self.fp = ForeignPlayer(self.name)

	def attack(self):
		self.fp.jingong()

	def defense(self):
		self.fp.fangshou()

if __name__ == '__main__':
	b = Player(&quot;Bdier&quot;)
	b.attack()

	m = Player(&quot;Mical&quot;)
	m.attack()

	ym = Translator(&quot;YaoMing&quot;)
	ym.attack()
	ym.defense()
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Python的迭代器，可迭代对象和生成器</title>
   <link href="http://cuijintao.github.io/posts/iter.html"/>
   <updated>2017-04-08T00:00:00-07:00</updated>
   <id>/posts/iter</id>
   <content type="html">&lt;h2 id=&quot;可迭代对象和迭代器对象&quot;&gt;可迭代对象和迭代器对象&lt;/h2&gt;
&lt;p&gt;可迭代对象&lt;code&gt;iterable&lt;/code&gt;可通过内置方法&lt;code&gt;iter()&lt;/code&gt;生成迭代器对象&lt;code&gt;iterator&lt;/code&gt;。
可以使用此方法的对象自身为迭代器或序列，即自身存在&lt;code&gt;__iter__&lt;/code&gt;或&lt;code&gt;__getitem__&lt;/code&gt;属性。
迭代器可使用&lt;code&gt;next()&lt;/code&gt;方法生成下一个元素，最终抛出&lt;code&gt;StopIteration&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;for循环的实质：
先调用可迭代对象的&lt;code&gt;__iter__&lt;/code&gt;方法将其转换为一个迭代器，再对迭代器重复执行&lt;code&gt;next&lt;/code&gt;方法直到捕获&lt;code&gt;StopIteration&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;适用于一些惰性场合：
通过构造可迭代对象可以实现在for循环过程中的延时访问, 并将所有函数运行结果封装到一个对象当中。&lt;/p&gt;

&lt;p&gt;构造可迭代对象的步骤：
1.构造迭代器对象。继承&lt;code&gt;Iterator&lt;/code&gt;对象并重写&lt;code&gt;next&lt;/code&gt;接口，该接口中的方法为需要延时访问的函数或方法逻辑。
2.构造可迭代对象。继承&lt;code&gt;Iterable&lt;/code&gt;对象并重写&lt;code&gt;__iter__&lt;/code&gt;接口，返回步骤1中构造的迭代器对象实例。&lt;/p&gt;

&lt;p&gt;demo：
非迭代版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import time

def func(x):
	time.sleep(2)
	print 'run func...'
	return x

if __name__ == '__main__':
    # 结果对象为[func(1), func(2), func(3)]
	for x in [func(1), func(2), func(3)]:
		print x

########################################
# OUTPUT:
# run func...
# run func...
# run func...
# 1
# 2
# 3
########################################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;迭代版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from collections import Iterable, Iterator
import time

class MyIterator(Iterator):

	def __init__(self, num_list):
		super(MyIterator, self).__init__()
		self.num_list = num_list
		self.index = 0

	def next(self):
		if self.index == len(self.num_list):
			# tip:	can't return
			raise StopIteration
		else:
			result = self.func(self.num_list[self.index])
			self.index += 1
			return result

	def func(self, x):
		time.sleep(2)
		print 'run func...'
		return x

class MyIterable(Iterable):

	def __init__(self, num_list):
		super(MyIterable, self).__init__()
		self.num_list = num_list

	def __iter__(self):
		return MyIterator(self.num_list)

if __name__ == '__main__':
    # 结果对象为MyIterable([1,2,3])
	for x in MyIterable([1,2,3]):
		print x

########################################
# OUTPUT:
# run func...
# 1
# run func...
# 2
# run func...
# 3
########################################
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;生成器函数&quot;&gt;生成器函数&lt;/h2&gt;
&lt;p&gt;函数体中带有&lt;code&gt;yield&lt;/code&gt;的函数几位生成器函数，调用生成器函数将返回一个生成器对象。
生成器对象也是一个可迭代对象。(可以调用&lt;code&gt;__iter__&lt;/code&gt;函数)
也是一个迭代器对象。（可以调用&lt;code&gt;next&lt;/code&gt;函数）&lt;/p&gt;

&lt;p&gt;因此可以将某个类的&lt;code&gt;__iter__&lt;/code&gt;方法实现为生成器函数来实现可迭代对象。&lt;/p&gt;

&lt;p&gt;素数demo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class PrimeNumber:

	def __init__(self, start, stop):
		self.start = start
		self.stop = stop

	def is_prime(self, num):
		if num &amp;lt; 2:
			return False
		for i in range(2, num):
			if num % i == 0:
				return False
		return True

	def __iter__(self):
		for i in range(self.start, self.stop + 1):
			if self.is_prime(i):
				yield i

for i in PrimeNumber(0, 100):
	print i 

&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Pro Git整理</title>
   <link href="http://cuijintao.github.io/posts/git.html"/>
   <updated>2017-04-03T00:00:00-07:00</updated>
   <id>/posts/git</id>
   <content type="html">&lt;p&gt;学习自Pro Git文档，在此处进行梳理。&lt;/p&gt;

&lt;h2 id=&quot;一些未知概念&quot;&gt;一些未知概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Git 对待数据更像是一个 快照流。&lt;/li&gt;
  &lt;li&gt;你执行的 Git 操作，几乎只往 Git 数据库中增加数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;git存在三个层级的配置级别，后一级别的配置项会覆盖前一层级的配置项。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;git config --system&lt;/code&gt; 系统级别，读写&lt;code&gt;/etc/gitconfig&lt;/code&gt;文件。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;git config --global&lt;/code&gt; 当前用户级别，读写&lt;code&gt;~/.gitconfig&lt;/code&gt;或&lt;code&gt;~/.config/git/config&lt;/code&gt;文件。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;git config&lt;/code&gt; 当前仓库级别，读写&lt;code&gt;.git/config&lt;/code&gt;文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用户配置&quot;&gt;用户配置&lt;/h3&gt;
&lt;p&gt;只可填写一次，之后的任何一次commit都会使用该信息，不可修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;文本编辑器&quot;&gt;文本编辑器&lt;/h3&gt;
&lt;p&gt;默认为vim。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;检查配置信息&quot;&gt;检查配置信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;

&lt;h3 id=&quot;状态概览&quot;&gt;状态概览&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git status -s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新添加的未跟踪文件前面有 ?? 标记。
新添加到暂存区中的文件前面有 A 标记。
修改过的文件前面有 M 标记。 
出现在右边的 M 表示该文件被修改了但是还没放入暂存区。
出现在靠左边的 M 表示该文件被修改了并放入了暂存区。&lt;/p&gt;

&lt;h3 id=&quot;忽略文件&quot;&gt;忽略文件&lt;/h3&gt;
&lt;p&gt;通过创建&lt;code&gt;.gitignore&lt;/code&gt;文件来选择无需纳入git中的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;查看修改&quot;&gt;查看修改&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git diff 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工作区 vs 暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git diff --cached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;暂存区 vs 仓库&lt;/p&gt;

&lt;h3 id=&quot;跳过暂存区&quot;&gt;跳过暂存区&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -a -m &quot;message&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将所有被跟踪的文件都提交到仓库中&lt;/p&gt;

&lt;h3 id=&quot;重命名文件&quot;&gt;重命名文件&lt;/h3&gt;
&lt;p&gt;在git中体现的操作为先删除再新建&lt;/p&gt;

&lt;h3 id=&quot;提交历史&quot;&gt;提交历史&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git log -p -2
$ git log --stat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;用来显示每次变动，&lt;code&gt;-2&lt;/code&gt;显示近两次提交。
&lt;code&gt;--stat&lt;/code&gt;用来显示所有被修改过文件的修改情况。
&lt;code&gt;--graph&lt;/code&gt;用来显示分支合并情况。
&lt;code&gt;--pretty&lt;/code&gt;指定显示格式。
&lt;code&gt;--graph&lt;/code&gt;指定分支合并情况。&lt;/p&gt;

&lt;h3 id=&quot;撤销操作&quot;&gt;撤销操作&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将暂存区里与上次提交历史合并并提交覆盖上次提交历史。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reset HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将暂存区内容恢复到与仓库一致&lt;/p&gt;

&lt;h2 id=&quot;远程仓库&quot;&gt;远程仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出所有远程仓库列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git fetch origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拉取远程仓库的分支引用，可以随时合并或查看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git remote show origin 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看远程分支信息&lt;/p&gt;

&lt;h2 id=&quot;git分支&quot;&gt;GIT分支&lt;/h2&gt;
&lt;p&gt;提交对象除了有指向快照的指针和作者邮箱等信息外，还具有指向父级提交对象的指针。
分支实际上为指向上一次提交对象的指针（可变指针）。
&lt;code&gt;HEAD&lt;/code&gt;是一个特殊指针，指向当前所在的本地分支。
&lt;code&gt;git log --decorate&lt;/code&gt;可查看各个分支指向的对象。
&lt;code&gt;git log --oneline --decorate --graph --all&lt;/code&gt;查看分支分叉情况。&lt;/p&gt;

&lt;h3 id=&quot;解决bug模式本地&quot;&gt;解决bug模式(本地)&lt;/h3&gt;
&lt;p&gt;切换到线上分支-&amp;gt;新建分支-&amp;gt;修改bug-&amp;gt;切换回线上分支-&amp;gt;合并分支-&amp;gt;返回工作分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b issbug
$ git commit -a -m &quot;fix bug&quot;
$ git checkout master
$ git merge issbug  # git会自动选用合适的方式来合并分支，fast-forward或strage
$ git branch -d issbug
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;分支管理&quot;&gt;分支管理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git branch --merged&lt;/code&gt;已合并到当前分支的所有分支。
&lt;code&gt;git branch -D test&lt;/code&gt;强制删除分支（不推荐）&lt;/p&gt;

&lt;h3 id=&quot;远程分支&quot;&gt;远程分支&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;origin/master&lt;/code&gt;远程分支是不能移动的本地指针，指向对远程分支状态的引用。只要不与远程仓库连接，该指针就不会移动。
&lt;code&gt;git fetch origin&lt;/code&gt;更新远程分支的引用，可以与本地分支分叉。
&lt;code&gt;git merge origin/master&lt;/code&gt;将远程分支合并到当前分支。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;跟踪分支：跟踪分支后在输入&lt;code&gt;git pull&lt;/code&gt;后git可以知道到哪拉取并合并数据。
&lt;code&gt;git checkout -b serverfix origin/serverfix&lt;/code&gt;建立本地分支并跟踪远程分支。
&lt;code&gt;git checkout --track origin/serverfix&lt;/code&gt;等同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;git branch -vv&lt;/code&gt;获取分支和跟踪信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拉取
&lt;code&gt;git pull&lt;/code&gt;相当于&lt;code&gt;git fetch&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;操作。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>SICP</title>
   <link href="http://cuijintao.github.io/posts/sicp.html"/>
   <updated>2017-03-26T00:00:00-07:00</updated>
   <id>/posts/sicp</id>
   <content type="html">&lt;h3 id=&quot;过程和数据&quot;&gt;过程和数据&lt;/h3&gt;

&lt;h3 id=&quot;替换&quot;&gt;替换&lt;/h3&gt;

&lt;h3 id=&quot;正则序和应用序&quot;&gt;正则序和应用序&lt;/h3&gt;
&lt;p&gt;习题1.5
相当于函数参数的求值顺序&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用序：先求值再带入函数过程，可以防止多次运算的情况出现。lisp是应用序。&lt;/li&gt;
  &lt;li&gt;正则序：先将函数过程展开再将参数替换进函数过程之中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;特殊函数&quot;&gt;特殊函数&lt;/h3&gt;
&lt;p&gt;习题1.6
编程语言中的&lt;code&gt;if&lt;/code&gt;函数经过特殊处理，在&lt;code&gt;if&lt;/code&gt;表达式计算结果为&lt;code&gt;true&lt;/code&gt;后不会再继续计算之后的表达式和值。
自行构造的&lt;code&gt;new-if&lt;/code&gt;函数不管内部如何，lisp总会计算所有表达式的值，之后将值替换到参数中（正则序也会无限展开），因此会进入无限递归中。&lt;/p&gt;

&lt;h3 id=&quot;递归计算过程和迭代计算过程&quot;&gt;递归计算过程和迭代计算过程&lt;/h3&gt;
&lt;p&gt;递归计算过程由一个推迟执行的运算链条刻画。
迭代计算过程则是通过状态变量描述的计算过程。&lt;/p&gt;

&lt;p&gt;在树形递归算法中，递归计算过程的复杂度要远远高于迭代计算过程。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RabbitMQ泛式</title>
   <link href="http://cuijintao.github.io/posts/rabbitmq.html"/>
   <updated>2017-03-24T00:00:00-07:00</updated>
   <id>/posts/rabbitmq</id>
   <content type="html">&lt;p&gt;掌握了一种rabbitmq设计的初步泛式，原理部分以后补充。&lt;/p&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;由4部分构成，消息生产者(P)，交换机(X)，队列(Q)，消息消费者(C)。
X：direct，topic，headers，fanout&lt;/p&gt;

&lt;h3 id=&quot;pub泛式&quot;&gt;pub泛式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;from librabbitmq import Connection

def connection_rabbit():
    global connection
    global channel
    connection = Connection(host=config[&quot;host&quot;], virtual_host=config[&quot;vhost&quot;],
                            userid=config[&quot;userid&quot;], password=config[&quot;password&quot;])
    channel = connection.channel()
    channel.exchange_declare(exchange=&quot;name&quot;, type=&quot;direct&quot;)
    print &quot;rabbitmq connect done&quot;
    
def send_message(routing, body):
    global channel
    channel.basic_publish(exchange=&quot;name&quot;, 
                        routing_key=routing,
                        body=body,
                        deliver_mode=2) # 消息持久化
    print &quot;[*] send message {0}: {1}: {2}&quot;.format(routing, body, &quot;timestamp&quot;)
    
if __name__ == '__main__':
    send_message(routing, params)
    # routing从参数中对应字典取出

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub泛式&quot;&gt;sub泛式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import ast
import sys
from librabbitmq import connection

def consume(queue_name, callback):
    connection = Connection(host=config[&quot;host&quot;], virtual_host=config[&quot;vhost&quot;],
                            userid=config[&quot;userid&quot;], password=config[&quot;password&quot;])
    channel = connection.channel()
    channel.exchange_declare(exchange=&quot;name&quot;, type=&quot;direct&quot;)
    channel.queue_declare(queue=queue_name, durable=True) #队列持久化
    channel.queue_bind(exchange=&quot;direct&quot;, queue=queue_name,                     
                    routing_key=queue_name)
    channel.basic_qos(prefetch_count=1) #每个worker在接受到一条消息后不会再被分配消息
    channel.basic_consume(callback=callback, queue=queue_name)
    
    print &quot;[*] Waiting for tasks. To exit press CTRL+C&quot;
    while True:
        connection.drain_events()
        
def callback(message):
    # callback会将body作为参数传入
    params = ast,literal_eval(str(message.body))
    print &quot;[*] Receive message {}&quot;.format(params)
    global routing
    if routing == &quot;1&quot;:
        class1(params).func1()
    elif ...
    ...
    else:
        pass
    message.ack()
    
if __name__ == &quot;__main__&quot;:
    global routing
    routing = sys.argv[1]
    consume(routing, callback)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>再看redis</title>
   <link href="http://cuijintao.github.io/posts/redis.html"/>
   <updated>2017-03-01T00:00:00-08:00</updated>
   <id>/posts/redis</id>
   <content type="html">&lt;p&gt;之前只是将redis当做celery通信的中间件，并没有特别关注其独有特性。再回看redis，其许多特性可以应用到不同的场景中，且效率比一般关系型数据库要高。&lt;/p&gt;

&lt;h2 id=&quot;几种数据类型的优势&quot;&gt;几种数据类型的优势&lt;/h2&gt;
&lt;p&gt;redis作为一种NoSQL数据库，自然可以适应高并发和海量数据的存储，同样以key作为检索的唯一索引，不能对复杂的逻辑关系提供很好的支持。但其被广泛认作key-value型存储结构的数据库，其实有失偏颇。redis除了string是典型的key-value结构外，其余数据结构都有其独特应用。&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;
&lt;p&gt;redis的list链表结构，由于其有序性，在链表的两头插入和删除元素都十分高效，时间复杂度为O(1)。但在链表中间插入和删除数据效率会下降，时间复杂度为O(N)。&lt;/p&gt;

&lt;h3 id=&quot;hash&quot;&gt;hash&lt;/h3&gt;
&lt;p&gt;hash结构是具有string类型的field-value的映射表，适合存储对象信息，hash中的字段较少时占用内存也比较低。&lt;/p&gt;

&lt;h3 id=&quot;set&quot;&gt;set&lt;/h3&gt;
&lt;p&gt;set集合中的元素没有顺序，不允许重复，增查更新的时间复杂度均为O(1)，可以再服务器端进行求并集差集运算，效率很高。&lt;/p&gt;

&lt;h3 id=&quot;ordered-set&quot;&gt;ordered set&lt;/h3&gt;
&lt;p&gt;同set集合一样，只不过对每个元素都结合了一个score关联进行排序，实现增删改的操作非常迅速，时间复杂度为O(logN)，这在其他关系型数据库中是比较难实现的。&lt;/p&gt;

&lt;h3 id=&quot;应用场景&quot;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;这里模拟了一些可以用redis解决的场景。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;典型Pub-Sub场景&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是redis可以实现的最为典型的场景&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# pub.py

import redis
r = redis.Redis(host='localhost', port=6379)
r.publish('en', 'hello, world')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# sub.py

import redis
r = redis.Redis(host='localhost', port=6379)
pubsub = r.pubsub()
pubsub.subscribe('en')
for item in pubsub.listen():
    print item
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;最近登录列表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模拟队列并保持队列内元素数目为定值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uid = randint(0, 9)
ret = r.lpush('login:last_login_times', uid)
ret = r.ltrim('login:last_login_times', 0, 4)
last_login_list = r.lrange('login:last_login_times', 0, 4)
print last_login_list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;生产者消费者模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生产者推送消息，消费者执行，生成备份消息队列防止消息丢失。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if r.llen('message') &amp;lt; 2:
	r.lpush('message', 1,2,3)
msg = randint(0, 9)
r.lpush('message', msg)
r.rpoplpush('message', 'message_backup')
print r.lrange('message', 0, -1)
print r.lrange('message_backup', 0, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;积分排行榜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;玩家分数变化时用zadd更新玩家分数，再用zrange获取积分top信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;if r.zcard('new_login_times') == 0:
	r.zadd('new_login_times', 'Bob', 1)
	r.zadd('new_login_times', 'Jack', 1)
	r.zadd('new_login_times', 'Crool', 1)

uid = randint(0, 2)
name = ['Bob', 'Jack', 'Crool'][uid]
print name
ret = r.zincrby('new_login_times', name, 1)
#login_times_list = r.zrevrange('new_login_times', 1, 3)
print r.zrevrange('new_login_times', 0, -1, withscores=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;共同关注
利用set的高效intersections命令，类似的还有suninostore求并集命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;r.sadd('s1', 'a', 'b', 'c', 'd')
r.sadd('s2', 'b', 'c', 'd', 'e')
r.sadd('s3', 'c', 'd', 'e', 'f')
r.sinterstore('result', 's1', 's2', 's3')
print r.smembers('result')
r.delete('s1', 's2', 's3', 'result')
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Master/Slave模型
利用list可以很容易实现分布式中的Master/Slave模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# RedusQueue.py

import redis

class RedisQueue(object):
    &quot;&quot;&quot;Simple Queue with Redis Backend&quot;&quot;&quot;
    def __init__(self, name, namespace='queue', **redis_kwargs):
        &quot;&quot;&quot;The default connection parameters are: host='localhost', port=6379, db=0&quot;&quot;&quot;
        self.__db= redis.Redis(**redis_kwargs)
        self.key = '%s:%s' %(namespace, name)

    def qsize(self):
        &quot;&quot;&quot;Return the approximate size of the queue.&quot;&quot;&quot;
        return self.__db.llen(self.key)

    def empty(self):
        &quot;&quot;&quot;Return True if the queue is empty, False otherwise.&quot;&quot;&quot;
        return self.qsize() == 0

    def put(self, item):
        &quot;&quot;&quot;Put item into the queue.&quot;&quot;&quot;
        self.__db.rpush(self.key, item)

    def get(self, block=True, timeout=None):
        &quot;&quot;&quot;Remove and return an item from the queue.

        If optional args block is true and timeout is None (the default), block
        if necessary until an item is available.&quot;&quot;&quot;
        if block:
            item = self.__db.blpop(self.key, timeout=timeout)
        else:
            item = self.__db.lpop(self.key)

        if item:
            item = item[1]
        return item

    def get_nowait(self):
        &quot;&quot;&quot;Equivalent to get(False).&quot;&quot;&quot;
        return self.get(False)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# master.py

from RedisQueue import RedisQueue

rq = RedisQueue('test')
for i in range(30):
	rq.put(i)
print rq.qsize()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# slave.py

import time
from RedisQueue import RedisQueue

rq = RedisQueue('test')
while not rq.empty():
	print rq.get()
	time.sleep(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;redis事务&quot;&gt;redis事务&lt;/h2&gt;
&lt;p&gt;redis事务被MULTI/EXEC/DISCARD/WATCH囊括，实际是串行顺序执行，执行期间redis不会再为客户端提供任何服务，从而保证事务的原子执行。&lt;/p&gt;

&lt;p&gt;EXEC/DISCARD类似于关系型数据库中的COMMIT/ROLLBACK语句。若在一次事务中发生错误redis将回滚所有操作。&lt;/p&gt;

&lt;p&gt;WATCH可以实现CAS即check-and-set锁。若在WATCH中监控的值发生改变，事务中的后续操作都不会被执行。这一特性可以很好地应用于多用户同时请求一个redis值时防止值得结果不一致。&lt;/p&gt;

&lt;h2 id=&quot;redis主从复制&quot;&gt;redis主从复制&lt;/h2&gt;
&lt;p&gt;redis可以很好地实现Master/Slave模型，此外其还有许多独有特性。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;同一个Master可以为多个Slave服务。&lt;/li&gt;
  &lt;li&gt;Slave和Slave之间也可以实现连接和同步请求。&lt;/li&gt;
  &lt;li&gt;S响应M是非阻塞的，期间M仍可以为客户端提供请求。&lt;/li&gt;
  &lt;li&gt;S之间的同步也是非阻塞的&lt;/li&gt;
  &lt;li&gt;可以设置S来实现只读的用户响应和保存数据的任务，以降低M的负荷。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ redis-server --port 6380 &amp;amp;
$ redis-cli -p 6380
127.0.0.1:6380&amp;gt; slaveof 127.0.0.1 6379
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就实现了主从复制，服务关闭后这种关系也消失，若想永久保存需要修改配置文件。&lt;/p&gt;

&lt;h2 id=&quot;redis持久化&quot;&gt;redis持久化&lt;/h2&gt;
&lt;p&gt;redis有三种（实际上是两种）持久化机制，快照（RDB)和追加式文件（AOF）。&lt;/p&gt;

&lt;p&gt;RDB会在固定时间将数据集快照写入磁盘，每一次写入都会覆盖之前的文件，因此只存在一个文件。方便归档和备份，但有数据丢失的危险。&lt;/p&gt;

&lt;p&gt;AOF则会在每次修改后将命令追加到AOF文件中，而且有redis-check-aof工具来解决命令执行一半宕机的问题。是一种非常可靠的持久化方式，缺点是速度慢，文件多。&lt;/p&gt;

&lt;p&gt;若有需求需要修改配置文件，此处不赘述。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>关于直播通</title>
   <link href="http://cuijintao.github.io/posts/zhibotong.html"/>
   <updated>2017-01-16T00:00:00-08:00</updated>
   <id>/posts/zhibotong</id>
   <content type="html">&lt;h2 id=&quot;直播通是什么&quot;&gt;直播通是什么？&lt;/h2&gt;
&lt;p&gt;直播通是一款实现跨平台主播信息集合的web应用，在这里你可以：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现跨平台主播搜索&lt;/li&gt;
  &lt;li&gt;实现不同平台主播的统一关注&lt;/li&gt;
  &lt;li&gt;实现主播的上线提醒通知&lt;/li&gt;
  &lt;li&gt;一键进入ta的直播间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单来说，就是将多家平台的主播搜索和关注系统集合到了一起。&lt;/p&gt;

&lt;p&gt;作为我个人来讲，这款web应用是我学习flask的第一个独立项目，也是我的第一个上线网站。从有想法，到最后部署成功，一共用了差不多一周时间。这其中的苦辣辛酸，波澜起伏想必只有各位开发者心里清楚，于是想写点东西记录下这个自己的处女作。&lt;/p&gt;

&lt;h2 id=&quot;设想&quot;&gt;设想&lt;/h2&gt;

&lt;p&gt;当我在琢磨用Python和flask能做什么事的时候，最开始也是陷入了惯性陷阱，就是做一个和书上差不多的个人博客，于是我决定仿个知乎。可我又不甘心于此，想把前端做的漂亮一点，然而这是个大坑，项目进行了几天，发现几乎多半时间都在和前端打交道，可我明明做的是后端啊，遂弃坑，想找个有趣点的东西做。这中间还要感谢老同学的提醒：和后端没关系的东西可以通通去掉。没错！&lt;/p&gt;

&lt;p&gt;于是，我从需求出发，考虑能否做一个解决实际问题的东西，于是想到了直播平台。&lt;/p&gt;

&lt;p&gt;看直播是一键很有趣的事情，尤其像嫖老师这种（捂脸），然而各大平台的竞争却给我们带来了不少困扰，之前只需要看斗鱼就可以了，喜欢的主播基本都在斗鱼。之后发生的事情大家也都知道，各大平台疯狂砸钱挖人，于是你发现你喜欢的那些主播可能分布于不同平台。这个时候怎么办呢，把每个主播的直播间都加入收藏夹？（我的收藏夹可是要放1024的哪有这么些地方）每天打开各大平台主页看看有没有自己的主播？（现在热门的直播平台已经有6家了，这么搞得累死）关注主播的微博或者QQ群及时掌握上线信息？（我往往看到微博消息的时候都过去几个小时了）&lt;/p&gt;

&lt;p&gt;于是我有了计划：我要把几个直播平台集合在一起，让用户在一个页面就能看到自己想看到的全部主播的信息&lt;/p&gt;

&lt;p&gt;有了需求之后，就要开始寻求解决方法，于是有了直播通的最初设想：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;爬虫爬取平台主播数据&lt;/li&gt;
  &lt;li&gt;flask做后端&lt;/li&gt;
  &lt;li&gt;bootstrap做前端（真的不想和前端打太多交道）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;刚开始做的时候只是希望能做到让用户在一个页面看到主播信息就好了，在项目进行过程中又逐渐加入了主播上线提醒，主播搜索的功能，来源于需求而高于需求啊同志们！&lt;/p&gt;

&lt;h2 id=&quot;项目进行&quot;&gt;项目进行&lt;/h2&gt;

&lt;p&gt;设想归设想，实际进行起来还是有不少麻烦。&lt;/p&gt;

&lt;p&gt;项目中的用户部分，我直接从《Flask Web开发》这本书中拿出代码，将用户权限等无用部分去掉，进行了一些翻译工作。&lt;/p&gt;

&lt;p&gt;爬虫部分，分为了三个部分，getName用来爬取对应平台和房间号的主播名字，LiveChecker用来爬去主播的在线状态，Search用来拿到平台上的搜索结果。本来想把前两个爬虫放到一起做的，后来发现个别平台并不能一次爬到主播的名字和在线状态，之后又考虑到在线状态要放到计划任务中做并集成上线提醒，所以分开。&lt;/p&gt;

&lt;p&gt;开始时主播的在线状态时放在视图函数中的，即每次打开主页都会跑一次爬虫，更新主播在线状态。后来发现这一过程响应很慢，网页转圈要转好久，这肯定是不行的。后来考虑解决方法，想到了celery。然而celery任务要和前端互动的话需要一些js知识，在这里我跳过了这个坑，直接用了celery中的计划任务部分，让爬虫每5分钟在后台跑一次更新主播状态，惊奇的发现这个过程中可以加入用户提醒，折腾一晚上后成功。之后主播在线状态完全由这个后台负责，用户再也不用等待服务器响应主播在线状态了。&lt;/p&gt;

&lt;p&gt;部署的相关问题可以参照我的另一篇博客 直播通部署路上的坑&lt;/p&gt;

&lt;p&gt;其他的一些小问题，大都在网上和别人的项目中找到了解决方案。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;搞这个东西的状态现在回头想想，其实也就是瞎折腾。作为一个初学者，过程中遇到很多问题，也发现还有许多东西需要学习。学习flask的时间不长，其中的一些东西理解还没有很到位，很多地方也只能照葫芦画瓢，代码也可能写的很丑。但就像在一间黑暗的房子里看到了一束光，我期待，很期待，走出房子的那天。&lt;/p&gt;

&lt;p&gt;崔同学
2017.1.16&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>flask项目中添加搜索功能</title>
   <link href="http://cuijintao.github.io/posts/search.html"/>
   <updated>2017-01-15T00:00:00-08:00</updated>
   <id>/posts/search</id>
   <content type="html">&lt;p&gt;这部分内容的起因是我想在自己的flask项目直播通中加入一个搜索框用来搜索数据库中的主播姓名，于是在网上搜索flask 搜索关键字，当时没注意出来的都是全文搜索的教程，一步步做下来却发现原来根本和自己的需求不符合，可见弄清需求是多么重要啊！虽然走了点弯路，却意外发现了全文搜索的方法。&lt;/p&gt;

&lt;h2 id=&quot;设置搜索框&quot;&gt;设置搜索框&lt;/h2&gt;
&lt;p&gt;考虑到用户体验，这里想做导航栏上的搜索框，也就是全局搜索框，这就要用到flask中的程序上下文g，在处理请求时用作临时存储的对象，每次请求都会重设这个变量。很显然，这里就需要将一个搜索框设置成为程序上下文，具体做法如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建搜索框
很简单，在forms中添加
    &lt;pre&gt;&lt;code&gt;class SearchForm(Form):
  search = StringField(u'', validators=[Required()])
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;这里的Required是必须的，否则每次点击搜索按钮都会运行搜索函数，web性能下降。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;定义全局变量
在main.view中写入：
    &lt;pre&gt;&lt;code&gt;@main.before_app_request
def before_request(): #定义全局变量
  g.search_form = SearchForm()
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;就将一个搜索框设置成为了程序上下文变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;创建搜索和搜索结果的视图函数
    &lt;pre&gt;&lt;code&gt;@main.route('/search', methods = ['POST'])
def search():
  if not g.search_form.validate_on_submit():
      return redirect(url_for('.index'))
  return redirect(url_for('.search_results', query = g.search_form.search.data))
@main.route('/search-results/&amp;lt;query&amp;gt;')
def search_results(query):
  pass
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;在模板中添加搜索框&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form class=&quot;navbar-form navbar-left&quot; action=&quot;&quot; method=&quot;post&quot; role=&quot;search&quot;&amp;gt;
	&amp;lt;div class=&quot;form-group&quot;&amp;gt;
		
		&amp;lt;input type=&quot;text&quot; name=&quot;search&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要注意flask_wtf的请求跨站保护和表单的name属性设置。
这样，一个全局搜索框就创建好啦！&lt;/p&gt;

&lt;h2 id=&quot;模糊搜索&quot;&gt;模糊搜索&lt;/h2&gt;
&lt;p&gt;模糊搜索其实很简单，只要对数据库中进行模糊检索即可，一条语句适用于很多场合：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User.query.filter(User.name.like('%'+query+'%')).all()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;全文搜索&quot;&gt;全文搜索&lt;/h2&gt;
&lt;p&gt;虽然有的时候模糊搜索很方便，但对于某些任务，比如搜索出现某些关键词的文章的时候就不能用模糊搜索了，因为不管关键词顺序还是空格都会影响模糊搜索的查询结果，这个时候就需要用到全文搜索。&lt;/p&gt;

&lt;p&gt;这里有一款实现全文搜索的良好flask扩展：WhooshAlchemy，在项目中应用也只需要简单几步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装： &lt;code&gt;pip install flask_whooshalchemy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;配置： 在配置文件config.py中写入要应用全文搜索的数据库路径：&lt;code&gt;WHOOSH_BASE=&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;索引对象：在models.py中需要全文搜索的对象中加入&lt;code&gt;__searchable__=['COLUMN']&lt;/code&gt;,COLOMN为需要搜索的列&lt;/li&gt;
  &lt;li&gt;在manage中添加索引：&lt;code&gt;whooshalchemy.whoosh_index(app, Model)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;最后在搜索时加入&lt;code&gt;Model.query.whoosh_search('keyword').all()&lt;/code&gt;即可
注意：使用whooshalchemy进行搜索要现将数据库中的要搜索的对象实例全部删除，这样才能创建索引，否则会报错。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>项目部署路上的坑</title>
   <link href="http://cuijintao.github.io/posts/gunicorn.html"/>
   <updated>2017-01-15T00:00:00-08:00</updated>
   <id>/posts/gunicorn</id>
   <content type="html">&lt;p&gt;直播通项目终于更新上线了，看到自己的第一个Web应用在服务器上正常运作并且各项功能正常，内心一阵暗爽。看了一眼时间，从有想法到最终项目上线，一共用了大概一周左右时间，作为一个简单的flask应用，这点时间不算长也不算短，其中部署只花了一晚上就弄好了，在这里要感谢已经工作的老友提供思路，虽然部署的时候也踩过不少坑，但确实少走了许多弯路。所谓前人栽树后人？哈？&lt;/p&gt;

&lt;h2 id=&quot;服务器选择&quot;&gt;服务器选择&lt;/h2&gt;
&lt;p&gt;这里直接选择了朋友推荐的腾讯云，一路低配，在选择内存时担心1G内存不够选了2G（心疼），最终抛过代金券还是花了90大洋。不过，值！&lt;/p&gt;

&lt;h2 id=&quot;部署思路&quot;&gt;部署思路&lt;/h2&gt;
&lt;p&gt;这里有两种思路可供选择，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gunicorn + supervisor + nginx, 部署流程简单清晰，但听说性能不好。&lt;/li&gt;
  &lt;li&gt;朋友推荐的gunicorn + pm2方案，但看了一眼pm2，全部时node.js相关的代码，超纲了啊！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的目的是让自。己的项目尽快跑起来，因此，选择了有较多参考资料和前人经验的第一种思路，第二种的话，以后在说吧。&lt;/p&gt;

&lt;h2 id=&quot;开始部署&quot;&gt;开始部署&lt;/h2&gt;

&lt;h3 id=&quot;部署准备&quot;&gt;部署准备&lt;/h3&gt;
&lt;p&gt;好，登录服务器，输入用户名和密码登录Linux（这里选择和我平时用的一样的Ubuntu 16.04 64位机），先按照网上的教程将python和虚拟环境弄好，之后git clone代码。等等，者一大堆错误是什么，又是用户权限又是链接错误，折腾了许久未果，于是退而求其此，直接将本地代码复制到服务器上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ scp -r easySee ubuntu@www.mydomain.com:/var/www/easySee
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刚开始不清楚这行代码的作用，照葫芦画瓢，于是很自然的在easySee目录下又嵌套了一个同名文件，好low。不过既然是自己的服务器，就先这样吧。之后在虚拟环境中安装requirements中的需求模块，部署准备完成。&lt;/p&gt;

&lt;h3 id=&quot;gunicorn&quot;&gt;Gunicorn&lt;/h3&gt;

&lt;h4 id=&quot;是什么&quot;&gt;是什么&lt;/h4&gt;
&lt;p&gt;关于这部分内容，在部署的时候时完全没有考虑的，因为目的就是让项目尽快跑起来嘛。但不求甚解终归不是好的学习方法，还是要了解以下部署的每个部分是什么，能干嘛，于是补了这部分知识。&lt;/p&gt;

&lt;p&gt;gunicorn是一个Python WSGI UNIX的HTTP服务器，是一个per-fork worker模型。换句话说，Gunicorn一般用来管理多个进程，有进程挂了Gunicorn就可以把它拉起来，防止服务器长时间停止服务，还可以动态调整worker的数量，请求多的时候增加worker的数量，请求少的时候减少，这就是所谓的per-fork模型，也是Gunicorn的主要优点。其他优点还有能与各种web框架兼容，只需要非常简单的执行，轻量级的资源消耗以及很快的响应速度。&lt;/p&gt;

&lt;h4 id=&quot;怎么用&quot;&gt;怎么用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;安装
    &lt;pre&gt;&lt;code&gt;(venv) $ pip install gunicorn
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;运行(在项目根目录下)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ gunicorn -w 4 -b 127.0.0.1:8080 manage:app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本机上输入服务器ip及端口号后，马上看到了自己的应用。Yeah！这其实就是gunicorn的好处吧，根本不需要什么配置文件，一格指令就能将它启动。&lt;/p&gt;

&lt;p&gt;tip: 这里网上教程说还需要添加一个wsgi.py的文件替换掉manage.py，并特别注明wsgi.py和manage.py没有半毛钱关系。然而我的试验结果是，这两个完全就是一模一样的嘛-，- ,先这样吧，出了问题再说。&lt;/p&gt;

&lt;h3 id=&quot;nignx&quot;&gt;Nignx&lt;/h3&gt;

&lt;h4 id=&quot;是什么-1&quot;&gt;是什么&lt;/h4&gt;
&lt;p&gt;一个完整的代理请求过程为：客户端首先与代理服务器创建链接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建链接或者获得目标服务器的指定资源。Web代理服务器（proxy）是网络的中间实体，代理位于Web客户端与Web服务器之间，扮演中间人的角色。HTTP的代理服务器即是Web服务器，又是Web客户端。&lt;/p&gt;

&lt;p&gt;正向代理时一个介于客户端与原始服务器之间的服务器，为了从原始服务器获得内容，客户端向代理发送一个请求并指定目标，然后代理向原始服务器转交请求并将获得的内容返回给客户端。&lt;/p&gt;

&lt;p&gt;反向代理服务器：在服务器端接受客户端的请求，然后把请求分给具体的服务器进行处理，再将服务器的响应结果返回给客户端。&lt;/p&gt;

&lt;p&gt;Nginx(“engine x”)是一款高性能的HTTP和反向代理服务器软件，既可以托管网站，进行HTTP服务，也可以作为反向代理服务器使用。&lt;/p&gt;

&lt;p&gt;那么在Gunicorn前部署一层Nginx的目的是什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;负载均衡。&lt;/li&gt;
  &lt;li&gt;静态文件支持&lt;/li&gt;
  &lt;li&gt;伪静态化并缓存，减少动态请求数量&lt;/li&gt;
  &lt;li&gt;依赖于nginx强大的功能和性能，可以做到访问控制，限速，限制链接数等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说，nginx可以缓冲请求和响应，也能缓存客户端发起的请求，这个过程时nginx擅长处理的，可以有效提高Gunicorn的处理能力。&lt;/p&gt;

&lt;h4 id=&quot;怎么用-1&quot;&gt;怎么用&lt;/h4&gt;
&lt;p&gt;这里同样参照教程，安装完成后，直接进入Nginx的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/nginx/site-avalidable/default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，如果你怕搞错（就像我一样），可以先将配置文件备份&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo cp /etc/nginx/site-avalidable/default /etc/nginx/site-avalidable/default.bak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后将default暴力修改成下面的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    server_name 119.29.3.128; # 这是HOST机器的地址也
    location / {
        proxy_pass http://127.0.0.1:8080; # 这里是指向 gunicorn host 的服务地址
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后保存，重启Nignx服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo service nginx restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;supervisor&quot;&gt;supervisor&lt;/h3&gt;
&lt;h4 id=&quot;是什么-2&quot;&gt;是什么&lt;/h4&gt;
&lt;p&gt;Supervisor是一个用Python写的进程管理工具，可以很方便的用来启动，重启，关闭进程（不仅仅是Python进程），还可以很方便的管理多个进程，同时启动同时关闭等等。因此将gunicorn用supervisor来包装，很方便的管理进程运行，并且可以防止gunicorn服务器挂掉。而且如果项目中需要多进程运行时，也可以用supervisor来配置。&lt;/p&gt;

&lt;h4 id=&quot;怎么用-2&quot;&gt;怎么用&lt;/h4&gt;
&lt;p&gt;安装后首先将原始配置文件重定向到程序根目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo_supervisor_conf&amp;gt;supervisor.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实也可以不用进行这个步骤，但是每次打开supervisor服务时都要输入配置文件目录比较麻烦。
之后打开&lt;code&gt;supervisor.conf&lt;/code&gt;，在最后加上自己的进程信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[program:easySee]
command=/home/ubuntu/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 manage:app     ; supervisor启动命令
directory=/var/www/easySee/easySee                                         ; 项目的文件夹路径
startsecs=0                                                                ; 启动时间
stopwaitsecs=0                                                             ; 终止等待时间
autostart=false                                                            ; 是否自动启动
autorestart=true                                                           ; 是否自动重启
stdout_logfile=/.../app/data/log/gunicorn.log                              ; log 日志
stderr_logfile=/.../app/data/log/gunicorn.err                              ; 错误日志
[program:XXXXX]                                                            ; 用于多进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后启动supervisor&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ supervisord -c supervisor.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后的事不多说了，操作命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;supervisord -c supervisor.conf                             通过配置文件启动supervisor
supervisorctl -c supervisor.conf status                    察看supervisor的状态
supervisorctl -c supervisor.conf reload                    重新载入 配置文件
supervisorctl -c supervisor.conf start [all]|[appname]     启动指定/所有 supervisor管理的程序进程
supervisorctl -c supervisor.conf stop [all]|[appname]      关闭指定/所有 supervisor管理的程序进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要说下自己部署时出现的问题，在supervisor已经启动的状态下修改了配置文件，又不知道reload这个命令，于是想重新导入supervisor文件启动时出现了错误，提示端口正在被监听，这里给出解决方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ps -ef | grep supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后看到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root   2503  1  0 Nov19 ?  00:03:23 /usr/bin/python /usr/bin/supervisord
root   21337 2556  0 18:15 pts/8   00:00:00 grep --color=auto supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -s SIGTERM 2503
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;再说一点&quot;&gt;再说一点&lt;/h3&gt;
&lt;p&gt;写到这里，把部署期间的所有流程和问题处理基本又复习了一遍，主要用到的部分也大概知道都有什么作用了，再深入了解的话大概就到运维的范畴了，这次真的可以浅尝辄止了。&lt;/p&gt;

&lt;p&gt;部署并没有想象中的恐怖，只是折腾的时间要久一点罢了。CS这东西还真就全凭折腾，耐下性子干就是了，之后及时回头看看，收获颇丰呢。&lt;/p&gt;

&lt;p&gt;就这样啦。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>celery初探</title>
   <link href="http://cuijintao.github.io/posts/celery.html"/>
   <updated>2017-01-11T00:00:00-08:00</updated>
   <id>/posts/celery</id>
   <content type="html">&lt;p&gt;捣鼓了两天自己的直播通项目，终于大概有了雏形，在主页的视图函数中集成了爬虫，爬取用户关注主播的在线hangtag。但在运行时发现打开主页时延迟明显，有时候竟然长达数秒，突然想起了之前了解到的celery，试试能不能解决这一问题。&lt;/p&gt;

&lt;h2 id=&quot;celery是什么&quot;&gt;celery是什么&lt;/h2&gt;
&lt;p&gt;关于celery的知识全部在网上了解，星星点点，但还是有所收获。celery是一个典型的异步任务系统，在应用上下文之外执行任务，将消耗资源的东西通通交给celery来做，可以让主机迅速向应客户端的请求。&lt;/p&gt;

&lt;p&gt;celery有三个核心组件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端：在flask系统中和flask一起运行&lt;/li&gt;
  &lt;li&gt;workers：就是传说中的second terminal，用来执行异步任务，可以有多个&lt;/li&gt;
  &lt;li&gt;消息代理：用来进行celery的通信，一般用redis。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么用redis？因为其实时性强，一般用作数据频繁插入，更新或者删除的任务中，以减少对数据库的操作&lt;/p&gt;

&lt;h2 id=&quot;让celery跑起来&quot;&gt;让celery跑起来&lt;/h2&gt;

&lt;p&gt;这部分还是比较简单的，有几个主要步骤。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装之后要在配置文件中写入用作消息代理的redis的服务器，两行搞定。
    &lt;pre&gt;&lt;code&gt;CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;之后创建celery实例，这里是直接抄来的，至于原因还没搞懂。
    &lt;pre&gt;&lt;code&gt;celery = Celery(__name__, broker=Config.CELERY_BROKER_URL)
celery.conf.update(app.config)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;创建celery任务，使用装饰器，先跑起来再说。
    &lt;pre&gt;&lt;code&gt;@celery.task(name='circle_task')
def circletask():
  logging.info('lalala')
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后满怀信心，直接打开三个终端开始有样学样，第一个打开redis-server，第二个运行app，第三个打开celery，抄了个命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ celery -A manage.celery worker --loglevel=info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而打开后发现没有动静，才想起并没有提供任务执行的delay。随即又想到我的目的是进行计划任务，让任务可以固定时间重复进行，直接开始搜celery进行实现的方法，还好google够强大，又找到了下面的配置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CELERYBEAT_SCHEDULE = {
        'every-minute': {
            'task': 'circle_task',
            #'schedule': crontab(minute='*/1'),
            # 'args': (1,2),
            'schedule': timedelta(seconds=60)
        	},
    	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令也变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ celery -A manage.celery worker --loglevel=info --beat
$ celery -A proj worker -B -l info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于里面的参数，只知道timedelta和crontab都可以设置间隔时间，其他的没有深入了解。将代码改好后运行celery，问题来了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先是celery说任务方法没有注册：
    &lt;pre&gt;&lt;code&gt;Received unregistered task of type 'circle_task'.
The message has been ignored and discarded.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在stack overflow溜达了一圈，终于找到解决方法，在配置文件中声明这个方法即可，于是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CELERY_IMPORTS = ['app.task']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决成功。这里千万注意加app，天知道我经历了什么。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;之后运行celery，终于不报错了天呐，屏幕上也出现了lalala的logging，这还说什么，改代码！在task中添加了之前在index视图函数中的爬虫部分，运行celery，好，可以运行。等等，这一大片红字是什么！
    &lt;pre&gt;&lt;code&gt;'RuntimeError: application not registered on db 
         instance and no application bound to current context
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;原来是没有程序上下文不能进行sqlalchemy的操作，于是，在程序段前添加&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;with app.app_context():
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;成功！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/567571/88020dc0eeab8185.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后终于成功看到了模拟上线提醒的logging字样，激动万分，编程的大起大落真是…哈！&lt;/p&gt;
</content>
 </entry>
 
 
</feed>