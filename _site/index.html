<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="AwakeBird - 崔金涛个人博客 - 作者:崔金涛"/>
    <title>AwakeBird - 崔金涛个人博客</title>
    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet"/>
    <!-- Custom CSS -->
    <link href="/css/blog.css" rel="stylesheet"/>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media
    queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file://
    -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js">
      </script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js">
      </script>
    <![endif]-->
        <!-- jQuery Version 1.11.0 -->
    <script src="/js/jquery-1.11.0.js"> </script>
    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>
  </head>
  
  <body>
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">
              Toggle navigation
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
          </button>
          <a class="navbar-brand" href="/">
            首页
          </a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          		<ul class="nav navbar-nav">
			
				<li>
				  <a href="/posts/work.html">
					工作经验
				  </a>
				</li>
			
				<li>
				  <a href="/posts/study.html">
					学习笔记
				  </a>
				</li>
			
				<li>
				  <a href="/posts/other.html">
					随笔
				  </a>
				</li>
			
		</ul>  
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>
    <!-- Page Content -->
    <div class="container">
      <div class="row">
        <!-- Blog Entries Column -->
        <div class="col-md-8">
          <!-- Loop output paged posts -->

<h2>
  <a href="/posts/log.html">
    为Spring Boot添加日志模块
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-06-29
  </div>
</h2>
<hr>
<h1 id="概述">概述</h1>
<p>SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。</p>

<p>Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。</p>

<p>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。</p>

<h1 id="配置">配置</h1>

<h2 id="添加依赖">添加依赖</h2>

<p>一般来说需要添加spring-boot-starter-logging：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>实际开发并不需要直接添加依赖，spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h2 id="自定义日志配置">自定义日志配置</h2>

<p>添加好依赖后原则上讲就可以开始使用日志模块了，但使用的是Spring Boot提供的很多默认配置，在<code>application.properties</code>中也只能修改部分属性，往往不能满足需求，因此需要自行定制配置文件实现日志配置。</p>

<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项。</p>

<p>在<code>src/main/resources</code>路径下添加<code>logback-spring.xml</code>作为日志配置文件：</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration  scan="true" scanPeriod="60 seconds" debug="false"&gt;
    &lt;contextName&gt;logback&lt;/contextName&gt;
    &lt;property name="log.path" value="C:\\Users\\cuijintao\\logback.log" /&gt;
    &lt;!--输出到控制台--&gt;
    &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--输出到文件--&gt;
    &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
        &lt;file&gt;${log.path}&lt;/file&gt;
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
            &lt;fileNamePattern&gt;C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;20&lt;/maxHistory&gt;
            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level="info"&gt;
        &lt;appender-ref ref="console" /&gt;
        &lt;appender-ref ref="file" /&gt;
    &lt;/root&gt;

    &lt;!-- logback为java中的包 --&gt;
    &lt;logger name="com.example.demo"/&gt;
    &lt;!--logback.LogbackDemo：类的全路径 --&gt;
    &lt;logger name="com.example.hello" level="WARN" additivity="false"&gt;
        &lt;appender-ref ref="file"/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>

<h3 id="根节点configuration属性">根节点<code>&lt;configuration&gt;</code>属性</h3>

<ul>
  <li>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>
  <li>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>
  <li>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>
</ul>

<h4 id="属性1---上下文名称contextname">属性1 - 上下文名称<code>&lt;contextName&gt;</code>:</h4>
<p>每个logger都关联到logger上下文，默认上下文名称为“default”。
之后可以通过%contextName来打印日志上下文名称。</p>
<pre><code>&lt;contextName&gt;logback&lt;/contextName&gt;
</code></pre>

<h4 id="属性2---属性变量property">属性2 - 属性变量<code>&lt;property&gt;</code></h4>
<p>定义一个key-value键值对
通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。</p>
<pre><code> &lt;property name="log.path" value="C:\\Users\\cuijintao\\logback.log" /&gt;
</code></pre>

<h4 id="子节点1---appender">子节点1 - <code>&lt;appender&gt;</code></h4>
<p>appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。</p>

<p><code>&lt;encoder&gt;</code>表示对日志进行编码：</p>
<ul>
  <li><code>%d{HH: mm:ss.SSS}</code> : 日志输出时间</li>
  <li><code>%thread</code> : 日志输出进程名字</li>
  <li><code>%-5level</code>: 日志级别 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</li>
  <li><code>%logger{36}</code> : 日志输出者名字</li>
  <li><code>%msg</code>: 日志消息</li>
  <li><code>%n</code>:　平台换行符</li>
</ul>

<p>输出到文件时，RollingFileAppender用于切分文件日志：</p>
<pre><code>    &lt;!--输出到文件--&gt;
    &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
        &lt;file&gt;${log.path}&lt;/file&gt;
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
            &lt;fileNamePattern&gt;C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;20&lt;/maxHistory&gt;
            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
</code></pre>

<ul>
  <li><code>&lt;fileNamePattern&gt;</code>: 指定日志的切分方式</li>
  <li><code>&lt;maxHistory&gt;</code>: 指定保留的切分文件的个数</li>
  <li><code>&lt;totalSizeCap&gt;</code>: 指定日志文件的上限大小，超过此值将会被删除</li>
</ul>

<h4 id="子节点2---root">子节点2 - <code>&lt;root&gt;</code></h4>
<p>必选节点，用来指定最基础的日志输出级别，只有一个level属性。
默认值为DEBUG.</p>
<pre><code>&lt;root level="debug"&gt;
  &lt;appender-ref ref="console" /&gt;
  &lt;appender-ref ref="file" /&gt;
&lt;/root&gt;
</code></pre>

<h4 id="子节点3---loger">子节点3 - <code>&lt;loger&gt;</code></h4>
<p><code>&lt;loger&gt;</code>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<code>&lt;appender&gt;</code>。
仅有一个name属性，一个可选的level和一个可选的addtivity属性。</p>

<ul>
  <li><code>name</code>: 用来指定受此loger约束的某一个包或者具体的某一个类。</li>
  <li><code>level</code>: 日志级别</li>
  <li><code>addtivity</code>: 是否向上级loger传递打印信息。默认是true。</li>
</ul>

<h4 id="多环境日志输出">多环境日志输出</h4>
<p>据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：</p>

<pre><code>&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;
&lt;springProfile name="test,dev"&gt;
    &lt;logger name="com.dudu.controller" level="info" /&gt;
&lt;/springProfile&gt;
&lt;!-- 生产环境. --&gt;
&lt;springProfile name="prod"&gt;
    &lt;logger name="com.dudu.controller" level="ERROR" /&gt;
&lt;/springProfile&gt;
</code></pre>

<p>在启动或打包服务是配置profile参数即可。
如启动时指定prod的方式为：</p>
<pre><code>java -jar xxx.jar --spring.profiles.active=prod
</code></pre>

<h1 id="demo">demo</h1>
<p>这里启动一个hello world的spring-boot模板来测试日志配置。</p>
<pre><code>package com.example.demo.com.example.demo.hello;

import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class HelloController {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @RequestMapping("/hello")
    public String index() {

        logger.info("日志测试 info");
        logger.debug("日志测试 debug");

        return "Hello World";
    }

}
</code></pre>
<p>根据上面的配置，日志文件中只记录了INFO级别的日志，每分钟对日志文件进行了切分。</p>


	<p><h3><a href="/posts/log.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/mule.html">
    通过MULE实现后端服务调用
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-06-28
  </div>
</h2>
<hr>
<h1 id="概述">概述</h1>

<h2 id="1简介">1.简介</h2>
<p>Mule ESB是一个基于Java的轻量级企业服务总线和集成平台，允许开发人员快速便利地连接多个应用，并支持应用间的数据交换。Mule ESB支持集成现有系统而无论其底层采用何种技术，如JMS、Web Services、JDBC、HTTP以及其他技术。</p>

<h2 id="2整体结构">2.整体结构</h2>
<p><img src="http://my.oschina.net/uploads/space/2010/1206/131219_BfeJ_49921.jpg" alt="此处输入图片的描述" />
Mule通过Transports/Connectors与外围的异构系统连接，提供Routing（路由）、Transaction Management（事务管理）、Transformation（转换）、Message Broker（消息代理）、Transportation Management（传输管理）、Security（安全）等核心模块。Mule可以单独使用，也可以架设在常用的应用服务器上。</p>

<p><img src="http://my.oschina.net/uploads/space/2010/1206/104036_uBGk_49921.jpg" alt="此处输入图片的描述" />
外围系统的服务请求通过Mule ESB的Transport接入，Mule通过Transformer进行数据的格式转换，然后经过Inbound Router进行消息过滤（内部通过配置filter实现）后交给Mule的Component进行业务逻辑处理，处理后的结果通过Outbound Router确定传递给哪个接收方，然后通过Transformer进行数据格式转换，通过Transport连接至接收方，传递信息。</p>

<p>此图描述的是Mule中的一个典型场景的处理过程，涵盖了Mule中的各个关键组件。其中某些处理步骤不是必须的，如Inbound Router、Transformer。</p>

<h2 id="3功能">3.功能</h2>
<h3 id="服务中介">服务中介</h3>

<p>将业务逻辑和消息发送分离
屏蔽服务的消息格式和协议
提供任意位置的服务调用
提供协议桥接</p>

<h3 id="数据转换">数据转换</h3>

<p>在应用间交换不同格式的信息 
操作消息的负载内容，包括加密、压缩和编码转换
在异构的传输协议的数据类型间格式化消息</p>

<h3 id="消息路由">消息路由</h3>

<p>基于消息内容和复杂规则路由消息
消息的过滤、聚合以及重新排列序号</p>

<h3 id="服务创建和托管">服务创建和托管</h3>

<p>暴露端点、EJB、Spring Bean以及POJO作为服务
作为轻量级的服务容器进行服务托管</p>

<h1 id="mule的基本元素">Mule的基本元素</h1>
<h2 id="1flow">1.Flow</h2>
<p>使用<code>&lt;flow&gt;</code>元素在mule中配置Flow，Flow有一个name，消息源(一般由flow中定义的特定元素生成)和异常属性。</p>
<pre><code>&lt;flow name=""&gt;
    - 0..1 MessageSource
    - 1..n MessageProcessor(s)
    - 0..1 ExceptionStrategy
&lt;/flow&gt;
</code></pre>
<p>消息源接收或生成消息时，一个Flow将被启动，并根据Flow中所配置好的元素顺序进行执行。
特别的，当Flow为Request-Response模型时，Flow中最后一个消息处理器的处理结果作为相应返回，也可以在Flow中定义Response元素来处理相应。</p>

<h2 id="2message">2.Message</h2>
<p>Message负责在Mule中的数据传递，在Mule中主要存在三种Message形式。</p>

<h3 id="property">Property</h3>
<p>属性，键值对形式，分为入站和出站属性。</p>

<ul>
  <li>入站属性(Inbound properties)不可变，由消息源直接生成。
    <pre><code>#[message.inboundProperties]
</code></pre>
  </li>
  <li>出站属性(Outbound properties)可变，并可在流程中修改。
    <pre><code>#[message.outboundProperties]
</code></pre>
  </li>
</ul>

<h3 id="variables">Variables</h3>
<p>变量，完全由用户在流程内定义。</p>

<ul>
  <li>流变量(Flow variables) 只在其所在的Flow中可以使用。
    <pre><code>#[flowVars]
</code></pre>
  </li>
  <li>会话变量(Session variables) 适用于程序内所有的Flow。
    <pre><code>#[sessionVars]
</code></pre>
  </li>
  <li>记录变量(Record variables) 仅适用于批量处理。</li>
</ul>

<h3 id="payload">Payload</h3>
<p>参数传递，在Flow中流转的待处理参数，可以被修改和更改格式。</p>
<pre><code>#[payload]
</code></pre>

<p>Message可以引入特定Component进行设置。</p>

<h2 id="3connector">3.Connector</h2>
<p>连接器将Mule应用程序与第三方API和标准集成协议集成，从而提供访问Web服务和资源的方法。
使用Mule流中的连接器通过协议或使用API，发送和接收数据。</p>

<p>目前业务中涉及的连接器主要有HTTP连接器和AMQP连接器，其余连接器若有需要再行补充。</p>

<p>连接器的具体配置方法在下面业务场景中列出，配置好的连接器被储存在全局元素中，在任意的Flow中都可以引用并获得这个元素的实例。</p>

<h3 id="http-listener-connector">HTTP-Listener-Connector</h3>
<p>HTTP侦听器连接器提供了最实际的方式来监听HTTP请求。</p>

<p>连接器可以被配置为接受任何请求，或只接受寻址到特定URI的请求。可以选择连接器接受的方法：GET，POST等</p>

<p>请求body被传递到Flow作为的下一个元素的Payload放入Message，而Header，Query参数，URI参数和HTTP请求的其它元件被传递作为入站属性。这些属性可以从Message中访问。</p>

<p>此连接器还可以使用HTTPS协议，并通过TLS对通信进行加密。</p>

<pre><code>&lt;http:listener-config name="HTTP_Listener_Configuration" host="localhost" port="8081" doc:name="HTTP Listener Configuration"/&gt;
</code></pre>

<h3 id="http-request-connector">HTTP-Request-Connector</h3>
<p>HTTP请求连接器提供了消费外部HTTP服务的最实际的方法。发送HTTP请求时，您可以选择使用哪种方法（GET，POST等），并可能包含一个header，body，查询参数，表单参数和URI参数。然后响应由连接器接收，并传递给流中的下一个元素。</p>

<p>该连接器还可以实现HTTPS协议，并通过TLS对通信进行加密，还可以通过基本身份验证，OAuth，NTLM或摘要来实现身份验证。</p>

<pre><code>    &lt;http:request-config name="HTTP_Request_Configuration" host="127.0.0.1" port="5000" doc:name="HTTP Request Configuration" basePath="/"/&gt;
</code></pre>

<h3 id="amqp-connector">AMQP-Connector</h3>
<p>高级消息队列协议（AMQP）是一种开放标准，用于定义在应用程序或组织之间传递业务消息的协议。
AMQP连接器是先前引入的AMQP结构之上的一种抽象：连接，通道，交换，队列和消息。</p>

<p>连接器隐藏了低级概念，例如处理通道，但是对其封装的所有结构进行了大量的控制，从而允许您访问AMQP的丰富性，而无需对其API进行编码。</p>

<p>主要部件：</p>

<ul>
  <li>Connector： 建立与AMQP broker的联系，如rabbitmq，管理由使用此连接器的所有消费者或发布商共享的一组公共属性</li>
  <li>inbound-endpoint： 消耗来自AMQP队列的消息，将消息存入Mule的Message中</li>
  <li>outbound-endpoint： 从Mule Flow向AMQP交换机发布消息</li>
</ul>

<h1 id="mule的几种适用场景">Mule的几种适用场景</h1>

<h2 id="1一个经典的http转发模型">1.一个经典的HTTP转发模型</h2>

<h3 id="基本部件">基本部件</h3>
<p>核心由三个部分组成：HTTP-Liten-Connector, HTTP-Request-Connector, Set-Payload-Component，也可在之中即加入Echo-Component用于在Console中输出消息。</p>

<h3 id="配置">配置</h3>

<ul>
  <li>
    <p>HTTP-Listen配置：
General-&gt;General Setting-&gt;Connector Configuration-&gt;edit 指定HOST, PORT和BASE PATH
General-&gt;Basic Setting-&gt;Path 指定路由，*可以为任意路由，(此处可以应用到rest转发)
General-&gt;Response 中指定返回值(如配置Header实现跨域请求)</p>
  </li>
  <li>
    <p>Set-Payload配置:
General-&gt;Setting-&gt;value 指定请求body的值(原值传递<code>#[payload]</code>)
General-&gt;MIME Type Setting 指定请求body类型</p>
  </li>
  <li>
    <p>HTTP-Request配置(大部分和Listen相似，只需增加请求类型):
General-&gt;URL Settings-&gt;Method</p>
  </li>
</ul>

<h3 id="demo">demo</h3>

<pre><code>    &lt;http:listener-config name="HTTP_Listener_Configuration" host="localhost" port="8081" doc:name="HTTP Listener Configuration"/&gt;
    &lt;http:request-config name="HTTP_Request_Configuration" host="127.0.0.1" port="5000" doc:name="HTTP Request Configuration" basePath="/"/&gt;
    &lt;flow name="helloworldFlow"&gt;
        &lt;http:listener config-ref="HTTP_Listener_Configuration" path="test" responseStreamingMode="ALWAYS" doc:name="HTTP-Listen"&gt;
            &lt;http:response-builder&gt;
                &lt;http:header headerName="Access-Control-Allow-Origin" value="#[message.inboundProperties.'Access-Control-Allow-Origin']"/&gt;
            &lt;/http:response-builder&gt;
        &lt;/http:listener&gt;
        &lt;echo-component doc:name="Echo"/&gt;
        &lt;set-payload value="#[payload]" encoding="UTF-8" mimeType="application/json" doc:name="Set Payload"/&gt;
        &lt;http:request config-ref="HTTP_Request_Configuration" path="test" method="POST" doc:name="HTTP-Request"&gt;
            &lt;http:request-builder&gt;
                &lt;http:header headerName="Access-Control-Allow-Mthods" value="#[message.inboundProperties.'Access-Control-Allow-Mthods']"/&gt;
                &lt;http:header headerName="Cookie" value="#[message.inboundProperties.'Cookie']"/&gt;
            &lt;/http:request-builder&gt;
        &lt;/http:request&gt;
    &lt;/flow&gt;
</code></pre>

<h2 id="2一个经典的rabbitmq消息转发">2.一个经典的Rabbitmq消息转发</h2>

<h3 id="基本部件-1">基本部件</h3>
<p>Http-Listen-Connector, AMQP-Connector。其中AMQP相关连接器需要自行安装引入，我这里采用第三方软件包形式安装，还可通过官方软件包和Maven进行引入。</p>

<h3 id="配置-1">配置</h3>
<p>以HTTP-Listen和AMQP-EndPoint组成，其中HTTP-Listen和上面配置相同。</p>

<ul>
  <li>AMQP配置
Reference-&gt;Global Reference-&gt;Connector Reference-&gt;add 添加AMQP-Connector，Protoal全部采用默认值。
General-&gt;Address Attribute 配置Exchange和Queue</li>
</ul>

<h3 id="demo-1">demo</h3>
<pre><code>    &lt;amqp:connector name="AMQP_0_9_Connector" validateConnections="true" doc:name="AMQP-0-9 Connector"/&gt;
    &lt;http:listener-config name="HTTP_Listener_Configuration" host="localhost" port="8081" doc:name="HTTP Listener Configuration"/&gt;
    &lt;amqp:endpoint exchangeName="Kong" queueName="hello" name="AMQP_0_91" responseTimeout="10000" doc:name="AMQP-0-9"/&gt;
    &lt;flow name="test4Flow"&gt;
        &lt;http:listener config-ref="HTTP_Listener_Configuration" path="/" doc:name="HTTP"/&gt;
        &lt;amqp:outbound-endpoint connector-ref="AMQP_0_9_Connector" exchangeName="Kong" doc:name="AMQP-0-9" queueName="hello" responseTimeout="10000"/&gt;
    &lt;/flow&gt;
</code></pre>

<h2 id="3rest格式请求">3.REST格式请求</h2>

<p>大致与http格式相似，需要用到MULE表达式将HTTP-Listener中的path传递给HTTP-Request</p>

<h3 id="demo-2">demo</h3>
<pre><code>    &lt;http:listener-config name="HTTP_Listener_Configuration" host="localhost" port="8081" doc:name="HTTP Listener Configuration"/&gt;
    &lt;http:request-config name="HTTP_Request_Configuration" host="localhost" port="5000" doc:name="HTTP Request Configuration"/&gt;
    &lt;flow name="test5Flow"&gt;
        &lt;http:listener config-ref="HTTP_Listener_Configuration" path="/*" doc:name="HTTP"/&gt;
        &lt;http:request config-ref="HTTP_Request_Configuration" path="#[message.inboundProperties.'http.request.path']" method="GET" doc:name="HTTP"&gt;
            &lt;http:request-builder&gt;
                &lt;http:query-params expression="#[message.inboundProperties.'http.query.params']"/&gt;
            &lt;/http:request-builder&gt;
        &lt;/http:request&gt;
    &lt;/flow&gt;
</code></pre>


	<p><h3><a href="/posts/mule.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/bmpn.html">
    BPMN2.0概念
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-06-13
  </div>
</h2>
<hr>
<h2 id="1简介">1.简介</h2>

<p>BPMN（Business Process Model And Notation）- 业务流程模型和符号 是有BPMI（Business Process Management Initiative）开发的一套变准的业务流程建模符号。2004年5月发布了BPMN1.0规范.BPMI于2005年9月并入OMG（The Object Management Group)组织。OMG于2011年1月发布BPMI2.0的最终版本
![此处输入图片的描述][4]</p>

<h2 id="2规范">2.规范</h2>

<h3 id="21-bpmn2-conformance-一致性">2.1 BPMN2-Conformance 一致性</h3>

<ul>
  <li>
    <p>Process Modeling Conformance 流程模型一致性</p>
  </li>
  <li>
    <p>Process Execution conformance 流程执行一致性</p>
  </li>
  <li>
    <p>BPEL Process Execution Conformance BPEL 流程执行一致性</p>
  </li>
  <li>
    <p>Choreography Modeling Conformance 编排模型一致性</p>
  </li>
</ul>

<h3 id="22-bpmn2-element-元素">2.2 BPMN2-Element 元素</h3>
<p>![此处输入图片的描述][5]</p>
<h4 id="221-flow-objects-流对象">2.2.1 Flow Objects 流对象</h4>

<ul>
  <li>
    <p>Events 事件
![此处输入图片的描述][6]
Event 用一个圆圈表示，它是流程中运行过程中发生的事情。事件的发生会影响到流程的流转.事件包含Start\Intermediate\End三种类型.启动、结束、边界条件以及每个活动的创建、开始、流转等都是流程事件，利用事件机制，可以通过事件控制器为系统增加辅助功能，如其它业务系统集成、活动预警等.</p>
  </li>
  <li>
    <p>Activities 活动
![此处输入图片的描述][7]
活动用圆角矩形表示，一个活动多个活动组成，活动的类型分为Task和Sub-Process.     <br />
Task能描述业务过程中所有能发生工时的行为，是流程在流转过程中的一个原子活动，它被用于流程中的工作不能被拆开到更细级别时的场景.
Sub-Process事件子过程可以出现在过程或子过程中，其开始事件触发它活动，它可以中断上一层过程，也可以与上一层过程中的活动平行执行，这一切取决于它开始事件的行为。</p>
  </li>
  <li>
    <p>Gateways 网关
![此处输入图片的描述][8]
网关用菱形表示,用于控制流程的分支和聚合.决定流程流转指向.用来对流程中的决策进行建模。
(1)排他网关
(2)并行网关</p>
  </li>
</ul>

<h4 id="222-data-数据">2.2.2 Data 数据</h4>
<p>![此处输入图片的描述][9]
数据对象向读者显示在活动中需要或产生哪些数据.</p>

<ul>
  <li>
    <p>Data Objects 数据对象
代表过程中流动的信息，例如：业务文件、E-mail、信件。</p>
  </li>
  <li>
    <p>Data Inputs 数据输入
整个过程中可以被活动读取的外部数据.</p>
  </li>
  <li>
    <p>Data OutPuts 数据输出
作为整个过程的输出数据量.</p>
  </li>
  <li>
    <p>Data Stores 数据存储
存放过程数据的地方，例如数据库或文件。其生命周期超过了过程实例的生命周期，即过程实例结束了，但数据依然存在。</p>
  </li>
  <li>
    <p>Message 消息
消息用来表示两个参与者之间通讯的内容。</p>
  </li>
</ul>

<h4 id="223-connecting-objects-连接对象">2.2.3 Connecting Objects 连接对象</h4>
<p>![此处输入图片的描述][10]</p>

<ul>
  <li>
    <p>Sequence Flows 序列流
Sequence Flows 用实线实心箭头表示，代表流程中将被执行的活动的执行顺序.
是两个流程元素间的连接器.一个元素在流程执行期间被访问后，流程会沿着该元素输出的方向继续执行.</p>
  </li>
  <li>
    <p>Message Flows 消息流
Message Flows 用虚线空心箭头表示，第阿宝2个分开的流程参与者直接发送或者接收到的消息流.
消息流可以与泳池、活动或消息事件连在一起.</p>
  </li>
  <li>
    <p>Associations 结合关系
Associations 用点状虚线表示，用于显示活动的输入输出.</p>
  </li>
  <li>
    <p>Data Associations 数据结合关系</p>
  </li>
</ul>

<h4 id="224-swimlanes-泳道">2.2.4 Swimlanes 泳道</h4>
<p>![此处输入图片的描述][11]
泳池和泳道都表示活动的参与者，即表示过程中活动的执行者，它可以是一个组织、角色或系统。泳池可以划分成多个泳道，泳道具有分层结构.
是从视觉上对活动加以组织或分类的机制。它基于交叉功能流程图基础，在BPMN中有两种类型.</p>

<ul>
  <li>
    <p>Pools 池
表示流程中的主要参与者，典型地，用来分开不同的组织。一个池可容纳一个或多个道（像真实的泳池一样）。当池为展开的（显示出内部细节），绘做大的矩形；若为收起的（隐藏起内部细节），绘做沿着图的长或宽伸展的空的矩形。</p>
  </li>
  <li>
    <p>Lanes 道
在池中，用于活动按职能或角色归类。绘做按池的长或宽展开的矩形。道包含流对象、连接对象和人造物。</p>
  </li>
</ul>

<h4 id="225-artifacts-工件">2.2.5 Artifacts 工件</h4>
<p>![此处输入图片的描述][12]</p>

<ul>
  <li>
    <p>Group 组</p>
  </li>
  <li>
    <p>Text Annotation 文本注释</p>
  </li>
</ul>

<h3 id="23-流程">2.3 流程</h3>

<h4 id="231-流程图">2.3.1 流程图</h4>
<ul>
  <li>私有流程
指某一组织内部的流程，也叫工作流.在Web Service领域指服务的编制.</li>
  <li>共有流程
表现为一个私有流程和其他流程或参与者之间的交互.</li>
</ul>

<h4 id="232-协作图">2.3.2 协作图</h4>
<p>![此处输入图片的描述][13]
描绘两个或多个业务实体之间的交互.</p>

<h4 id="233-编排图">2.3.3 编排图</h4>
<p>![此处输入图片的描述][14]
表现多个参与者之间的交互，由编排活动直接表现多个参与者之间的消息交互，为协作模型提供了一种基于流程图的模型.</p>

<h4 id="234-会话图">2.3.4 会话图</h4>
<p>![此处输入图片的描述][15]
协作模型的另一种表现形式.</p>

	<p><h3><a href="/posts/bmpn.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/socketio.html">
    利用flask_socketio实现与前段的socket通信
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-05-16
  </div>
</h2>
<hr>
<h2 id="demo">Demo</h2>
<p><code>flask_socketio</code>将<code>flask</code>应用用socketio包装了一层，可以与web端实现websocket连接。</p>
<pre><code>from flask import Flask, render_template
from flask_socketio import SocketIO, emit

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret'
socketio = SocketIO(app)

@app.route('/')
def index():
    return render_template('index.html')
    
@socketio.on('connect')
def client_msg():
    print 'connect!'
    
@socketio.on('connect with token')
def connect_with_token(message):
    token = message['token']
    emit('notification', {'msg': 'done!'})
    
    
if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0', port=5300)
</code></pre>
<p><code>index.html</code>代码：</p>
<pre><code>&lt;script src="/static/node_modules/socket.io-client/dist/socket.io.js"&gt;&lt;/script&gt;
&lt;script&gt;
    function localConnectSocket(){
    var socket = io.connect('http://localhost:5300');
    socket.emit("connect with token", {'token': 'xxxx'});
    socket.on("notification", function (data) {
        alert(data.msg)
    });
    }
&lt;/script&gt;

&lt;body&gt;
    &lt;button type="button" onclick="localConnectSocket()"&gt;localConnectSocket&lt;/button&gt;
    &lt;br /&gt;
&lt;/body&gt;
</code></pre>

<h2 id="发送消息到特定连接">发送消息到特定连接</h2>
<p>每个连接有一个<code>sid</code>，存在<code>request.sid</code>中。
每个链接socketio会将其分配至一个以其<code>sid</code>为名的<code>room</code>中，据此可发送消息至每一个特定连接.</p>
<pre><code># Object that represents a socket connection
class Socket:
    def __init__(self, sid):
        self.sid = sid
        self.connected = True

    # Emits data to a socket's unique room
    def emit(self, event, data):
        emit(event, data, room=self.sid)

@socketio.on('connect')
def foo():
    sockets[request.sid] = Socket(request.sid)
</code></pre>


	<p><h3><a href="/posts/socketio.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/shejimoshi.html">
    大话设计模式Python实现
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-04-13
  </div>
</h2>
<hr>
<p>学习自大话设计模式，将其C#语言实现翻译为Python，同时参照此系列博客：<a href="http://www.jianshu.com/p/84ae207ccaf7">Python设计模式</a> 加深理解。</p>

<h2 id="1简单工厂模式">1.简单工厂模式</h2>

<p>面向对象目标：</p>

<ul>
  <li>可维护：只需要改动需求制定功能的类或模块</li>
  <li>可复用：可以用在不同的环境下</li>
  <li>可扩展：增加功能只需要增加相应的模块</li>
  <li>灵活性好：可以任意组合功能</li>
</ul>

<p>耦合性：更改一个功能不需要接触其他功能（即使功能都是相似的），考虑通过封装、继承和多态将耦合性降低。</p>

<p>根据需求实例化要实例的对象（这些对象可能均继承自同一基类）。</p>

<p>缺点：违反了高内聚职责分配原则 <a href="http://www.cnblogs.com/sevenyuan/archive/2010/03/05/1678730.html">职责分配原则</a></p>

<p>计算器实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
import re=

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a / self.b
		return result

class OperationFactory(object):
	def create_operation(self, operation, a, b):
		if operation == '+':
			return AddOperation(a, b)
		elif operation == '-':
			return SubtractOperation(a, b)
		elif operation == '*':
			return MultiplicationOperation(a, b)
		elif operation == '/':
			return DivisionOperation(a, b)
		else:
			raise ValueError

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][3]
		b = int(items[0][2])
		print OperationFactory().create_operation(operation, a, b).calculate_result()
	except:
		print 'Wrong Input.'
</code></pre>

<h2 id="2策略模式">2.策略模式</h2>

<p>将一系列算法家族封装，算法家族完成的是同一类功能的不同实现（都是用来解决同一个问题的，只是不同情况需要应用不同的算法），降低了客户端和算法类之间的耦合。</p>

<p>缺点：增加策略时仍然需要到<code>Context</code>类中增加一个新的判断分支。</p>

<p>超市活动实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Strategy(object):
	# 抽象算法类
	def algorithm_interface(self):
		raise NotImplementedError()

class NormalStrategy(Strategy):

	def algorithm_interface(self, money):
		return money

class RebateStrategy(Strategy):

	def __init__(self, rebate):
		self.rebate = rebate

	def algorithm_interface(self, money):
		return money*self.rebate

class ReturnStrategy(Strategy):

	def __init__(self, each_money, return_money):
		self.each_money = each_money
		self.return_money = return_money

	def algorithm_interface(self, money):
		return money-(money/self.each_money)*self.return_money

class Context(object):
	# 上下文，封装策略的实现细节
	def __init__(self, strategy_type):
		if strategy_type == 'normal':
			self.strategy = NormalStrategy()
		elif strategy_type == '0.8 rebate':
			self.strategy = RebateStrategy(0.8)
		elif strategy_type == '300 return 100':
			self.strategy = ReturnStrategy(300, 100)

	def context_interface(self, money):
		return self.strategy.algorithm_interface(money)

if __name__ == '__main__':
	money = int(raw_input('Enter money:'))
	strategy_type = raw_input('Enter strategy type:')
	print Context(strategy_type).context_interface(money)
</code></pre>

<h2 id="3单一职责原则">3.单一职责原则</h2>

<p>类的功能要尽量单一——利于解耦</p>

<h2 id="4开放封闭原则">4.开放封闭原则</h2>

<p>最扩展开放，最修改封闭。（写好的类尽量不要去改动他）
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
在最开始写代码时，假定变化不会发生，当变化发生之后，就要创建抽象来隔离变化。</p>

<h2 id="5依赖倒转原则">5.依赖倒转原则</h2>

<p>抽象不应该依赖于细节，细节应该依赖于抽象。
要对接口编程，而不要对实现编程。
里氏代换原则：子类必须能够替换掉他们的父类型。</p>

<h2 id="6装饰模式">6.装饰模式</h2>

<p>把每个需要装饰的功能放在单独的类中，需要使用新功能时只需要用装饰的类去包装原有的核心类，将类的核心职责和装饰功能分开，避免增加核心类的复杂度。</p>

<p>python自带的装饰器也是一种装饰模式的实现。</p>

<p>穿衣服实例</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
class Person(object):

	def __init__(self):
		self.name = ''

	def set_name(self, name):
		self.name = name

	def show(self):
		print u'装扮的{0}'.format(self.name)

class Finery(Person):

	def set_decorate(self, component):
		self.component = component

	def show(self):
		if self.component:
			self.component.show()

class TShirts(Finery):

	def show(self):
		print u'T-shirt.'
		super(TShirts, self).show()

class BigTrouser(Finery):

	def show(self):
		print u'Big-Trouser.'
		super(BigTrouser, self).show()

if __name__ == '__main__':
	xiao_ming = Person()
	xiao_ming.set_name('xiaoMing')

	print u'第一种装扮：'
	t_shirt = TShirts()
	big = BigTrouser()

	t_shirt.set_decorate(xiao_ming)
	big.set_decorate(t_shirt)

	big.show()
</code></pre>

<h2 id="7代理模式">7.代理模式</h2>

<p>用代理对象去调用真是对象的接口，可以完成一些额外的事。</p>

<p>代理和真是对象公用一个接口（继承自同一基类）。代理此接口的真正目的是调用真实对象的接口。</p>

<p>代码实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Subject(object):

	def request(self):
		raise NotImplementedError

class RealSubject(Subject):

	def request(self):
		print 'Real Request.'

class ProxySubject(Subject):

	def __init__(self):
		self.real = RealSubject()

	def request(self):
		self.real.request()

if __name__ == '__main__':
	proxy = ProxySubject()
	proxy.request()
</code></pre>

<h2 id="8工厂方法模式">8.工厂方法模式</h2>

<p>将简单工厂模式实例化类的时机延后到工厂子类进行，克服了简单工厂模式违背封闭原则的缺点。</p>

<p>但其仍有缺点：判断分支从工厂中转移到了客户端中进行。相当于绕了一圈又绕回来了。</p>

<p>计算器实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
import re

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a // self.b
		return result

class IFactory(object):
	def create_operation(self, a, b):
		raise NotImplementedError

class AddFactory(IFactory):
	def create_operation(self, a, b):
		return AddOperation(a, b)

class SubFactory(IFactory):
	def create_operation(self, a, b):
		return SubtractOperation(a, b)

class MulFactory(IFactory):
	def create_operation(self, a, b):
		return MultiplicationOperation(a, b)

class DivFactory(IFactory):
	def create_operation(self, a, b):
		return DivisionOperation(a, b)

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][1]
		b = int(items[0][2])
		if operation == '+':
			oper = AddFactory().create_operation(a, b)
		elif operation == '-':
			oper = SubFactory().create_operation(a, b)
		elif operation == '*':
			oper = MulFactory().create_operation(a, b)
		elif operation == '/':
			oper = DivFactory().create_operation(a, b)
		print oper.calculate_result()
	except:
		print 'Wrong Input.'
</code></pre>

<h2 id="9原型模式">9.原型模式</h2>

<p>从一个对象再创建一个可定制的对象，而且不需要知道任何创建的细节。（不需要再手动实例化一个新实例）
tip：这里涉及了深浅拷贝的概念。</p>

<p>优点：隐藏创建细节，提高性能。（不需要每次都调用构造函数）</p>

<pre><code class="language-python">import copy

class Book(object):
	def __init__(self, name, authors, price):
		self.name = name
		self.authors = authors
		self.price = price

	def clone(self, **kwargs):
		book_copy = copy.deepcopy(self)
		book_copy.__dict__.update(**kwargs)
		return book_copy

book1 = Book('Python', ['Tom', 'Jack'], 10)
book2 = book1.clone(price=20)
print book2.__dict__
# {'price': 20, 'name': 'Python', 'authors': ['Tom', 'Jack']}
</code></pre>

<h2 id="10-模板方法模式">10. 模板方法模式</h2>

<p>比较常见的设计模式，制定一种工作流或算法的特定骨架而将具体实现放到子类中。</p>

<pre><code class="language-python">class FatherClass(object):
    def tempmethod(self):
        print "first step: red"
        self.childmethod()
        print "third step: blue"
        
    def childmethod(self):
        raise NotImplementedError
    
class ChildClass1(FatherClass):
    def childmethod(self):
        print "second step: green"
        
class ChildClass2(FatherClass):
    def childmethod(self):
        print "second step: yellow"

</code></pre>

<h2 id="11迪米特法则">11.迪米特法则</h2>

<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p>

<p>强调类之间的松耦合。耦合度越低，越利于复用。</p>

<h2 id="12外观模式">12.外观模式</h2>

<p>给一组系统方法一个统一的接口，提供了一个更高层的接口方法。</p>

<p>有点类似代理模式。</p>

<pre><code class="language-python">class ModuleOne(object):
    def Create(self):
        print 'create module one instance'

    def Delete(self):
        print 'delete module one instance'

class ModuleTwo(object):
    def Create(self):
        print 'create module two instance'

    def Delete(self):
        print 'delete module two instance'

class Facade(object):
    def __init__(self):
        self.module_one = ModuleOne()
        self.module_two = ModuleTwo()

    def create_module_one(self):
        self.module_one.Create()

    def create_module_two(self):
        self.module_two.Create()

    def create_both(self):
        self.module_one.Create()
        self.module_two.Create()

    def delete_module_one(self):
        self.module_one.Delete()

    def delete_module_two(self):
        self.module_two.Delete()

    def delete_both(self):
        self.module_one.Delete()
        self.module_two.Delete()
</code></pre>

<h2 id="13建造者模式">13.建造者模式</h2>

<p>讲一个复杂对象的构建和他的表示分离，这样可以用同样的构建方式创建不同的表示。</p>

<p>优点：对象内部的构建顺序是稳定的，建造者隐藏了产品如何组装。</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Builder(object):
# 抽象建造者类，也可以说是产品类
	def part1(self):
		raise NotImplementedError

	def part2(self):
		raise NotImplementedError

class Builder1(object):

	def part1(self):
		print 'builder1 part1'

	def part2(self):
		print 'builder1 part2'

class Builder2(object):

	def part1(self):
		print 'builder2 part1'

	def part2(self):
		print 'builder2 part2'

class Director(object):

	def build(self, builder):
		builder.part1()
		builder.part2()

if __name__ == '__main__':
	builder = Builder1()
	director = Director()

	director.build(builder)
</code></pre>

<p>也可以将<code>Director</code>的代码已到<code>Builder</code>类中，实现模板方法模式。</p>

<pre><code class="language-python">class Builder(object):
    # ···
    def build(self):
        self.part1()
        self.part2()
</code></pre>

<h2 id="14观察者模式">14.观察者模式</h2>

<p>又称作Pub/Sub模式
定义了一种一对多的依赖关系，让众多观察者可以同时关注某一主题，当主题发生变化时每个观察者都会更新自己的状态。
许多MQ都是通过这一模式实现的。</p>

<pre><code class="language-python">class Topic(object):

	def __init__(self):
		self.obs = []

	def attach(self, observer):
		self.obs.append(observer)

	def detach(self, observer):
		self.obj.remove(observer)

	def notify(self, message):
		for observer in self.obs:
			observer.update(message)

class Observer(object):

	def update(self, message):
		raise NotImplementedError

class ConcreteObserver(Observer):

	def update(self, message):
		print message

if __name__ == '__main__':
	topic = Topic()
	ob1 = ConcreteObserver()
	ob2 = ConcreteObserver()
	topic.attach(ob1)
	topic.attach(ob2)
	topic.notify("hello")

</code></pre>

<h2 id="15抽象工厂模式">15.抽象工厂模式</h2>

<p>创建具有一定功能的产品实现时，需要先创建具体的工厂类，再由工厂类创建具有特定实现的产品对象。</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class IUser(object):

	def insert_user(self, user):
		raise NotImplementedError

	def get_user(self, userid):
		raise NotImplementedError

class IRole(object):
	def insert_role(self, role):
		raise NotImplementedError

	def get_role(self, roleid):
		raise NotImplementedError

class SqlServerUser(IUser):

	def insert_user(self, user):
		print u"在SQL Server中给User表增加一条记录."

	def get_user(self, userid):
		print u"在SQL Server中拿到一条uer信息。"

class SqlServerRole(IRole):
	def insert_role(self, role):
		print u"在SQL Server中给Role表增加一条记录"

	def get_role(self, roleid):
		print u"在SQL Server中拿到一条role记录"

# 产品类        
class AccessUser(IUser):
	def insert_user(self, user):
		print u"在Access中给User表增加一条记录."

	def get_user(self, userid):
		print u"在Access中拿到一条uer信息。"

class AccessRole(IUser):
	def insert_role(self, role):
		print u"在Access中给Role表增加一条记录"

	def get_role(self, roleid):
		print u"在Access中拿到一条role记录"

# 抽象工厂类
class IFactory(object):
	def create_user(self):
		raise NotImplementedError

	def create_role(self):
		raise NotImplementedError

# 具体工厂类
class SqlServerFactory(IFactory):

	def create_user(self):
		return SqlServerUser()

	def create_role(self):
		return SqlServerRole()

# 具体工厂类
class AccessFactory(IFactory):

	def create_user(self):
		return AccessUser()

	def create_role(self):
		return AccessRole()

class User(object):

	def __init__(self, id):
		self.id = id

class Role(object):

	def __init(self, id):
		self.id = id


if __name__ == '__main__':

	user = User(1)
	factory = SqlServerFactory()
	iu = factory.create_user()

	iu.insert_user(user)
	iu.get_user(1)
</code></pre>

<p>也可以考虑用引入简单工厂加反射进行优化。</p>

<h2 id="16状态模式">16.状态模式</h2>

<p>对象的行为取决于它的状态，并且他需要在运行时刻根据状态改变它的行为。</p>

<p>此时会产生大量判断语句，使用状态模式可以消除这些判断语句，降低耦合性。</p>

<p>工作实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class State(object):
	def write_program(work):
		raise NotImplementedError

class ForenoonState(State):
	def write_program(self, wrok):
		if work.hour &lt; 12:
			print u"当前时间: {}点， 上午工作，精神百倍".format(work.hour)
		else:
			wrok.set_state(NoonState())
			work.write_program()

class NoonState(State):
	def write_program(self, work):
		if work.hour &lt; 13:
			print u"当前时间：{}点， 饿了，午饭； 困了，午休".format(work.hour)
		else:
			work.set_state(AfternoonState())
			work.write_program()

class AfternoonState(State):
	def write_program(self, work):
		if work.task_finished:
			work.set_state(RestState())
		if work.hour &lt; 17:
			print u"当前时间：{}点， 下午状态不错，继续努力".format(work.hour)
		else:
			work.set_state(EveningState())
			work.write_program()

class EveningState(State):
	def write_program(self, work):
		print u"当前时间： {}点， 又要加班了！".format(work.hour)

class RestState(State):
	def write_program(self, work):
		print u"当前时间： {}点， 下班回家啦".format(work.hour)

class Work(object):
	def __init__(self):
		self.current = ForenoonState()
		self.hour = 9
		self.task_finished = False

	def set_hour(self, hour):
		self.hour = hour

	def set_finished(self, finished):
		self.set_finished = finished

	def set_state(self, state):
		self.current = state

	def write_program(self):
		self.current.write_program(self)

if __name__ == "__main__":
	work = Work()
	work.set_hour(9)
	work.write_program()
</code></pre>

<h2 id="17适配器模式">17.适配器模式</h2>

<p>当一个类的功能和数据相同而接口不同时，需要适配器模式充当翻译角色。</p>

<p>缺点：亡羊补牢</p>

<p>NBA翻译实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Player(object):
	def __init__(self, name):
		self.name = name

	def attack(self):
		print u"{} 进攻".format(self.name)

	def defense(self):
		print u"{} 防守".format(self.name)

class ForeignPlayer(object):

	def __init__(self, name):
		self.name = name

	def jingong(self):
		print u"{} 进攻".format(self.name)

	def fangshou(self):
		print u"{} 防守".format(self.name)

class Translator(Player):

	def __init__(self, name):
		super(Translator, self).__init__(name)
		self.fp = ForeignPlayer(self.name)

	def attack(self):
		self.fp.jingong()

	def defense(self):
		self.fp.fangshou()

if __name__ == '__main__':
	b = Player("Bdier")
	b.attack()

	m = Player("Mical")
	m.attack()

	ym = Translator("YaoMing")
	ym.attack()
	ym.defense()
</code></pre>


	<p><h3><a href="/posts/shejimoshi.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/iter.html">
    Python的迭代器，可迭代对象和生成器
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-04-08
  </div>
</h2>
<hr>
<h2 id="可迭代对象和迭代器对象">可迭代对象和迭代器对象</h2>
<p>可迭代对象<code>iterable</code>可通过内置方法<code>iter()</code>生成迭代器对象<code>iterator</code>。
可以使用此方法的对象自身为迭代器或序列，即自身存在<code>__iter__</code>或<code>__getitem__</code>属性。
迭代器可使用<code>next()</code>方法生成下一个元素，最终抛出<code>StopIteration</code>异常。</p>

<p>for循环的实质：
先调用可迭代对象的<code>__iter__</code>方法将其转换为一个迭代器，再对迭代器重复执行<code>next</code>方法直到捕获<code>StopIteration</code>异常。</p>

<p>适用于一些惰性场合：
通过构造可迭代对象可以实现在for循环过程中的延时访问, 并将所有函数运行结果封装到一个对象当中。</p>

<p>构造可迭代对象的步骤：
1.构造迭代器对象。继承<code>Iterator</code>对象并重写<code>next</code>接口，该接口中的方法为需要延时访问的函数或方法逻辑。
2.构造可迭代对象。继承<code>Iterable</code>对象并重写<code>__iter__</code>接口，返回步骤1中构造的迭代器对象实例。</p>

<p>demo：
非迭代版本</p>

<pre><code class="language-python">import time

def func(x):
	time.sleep(2)
	print 'run func...'
	return x

if __name__ == '__main__':
    # 结果对象为[func(1), func(2), func(3)]
	for x in [func(1), func(2), func(3)]:
		print x

########################################
# OUTPUT:
# run func...
# run func...
# run func...
# 1
# 2
# 3
########################################
</code></pre>

<p>迭代版本：</p>

<pre><code class="language-python">from collections import Iterable, Iterator
import time

class MyIterator(Iterator):

	def __init__(self, num_list):
		super(MyIterator, self).__init__()
		self.num_list = num_list
		self.index = 0

	def next(self):
		if self.index == len(self.num_list):
			# tip:	can't return
			raise StopIteration
		else:
			result = self.func(self.num_list[self.index])
			self.index += 1
			return result

	def func(self, x):
		time.sleep(2)
		print 'run func...'
		return x

class MyIterable(Iterable):

	def __init__(self, num_list):
		super(MyIterable, self).__init__()
		self.num_list = num_list

	def __iter__(self):
		return MyIterator(self.num_list)

if __name__ == '__main__':
    # 结果对象为MyIterable([1,2,3])
	for x in MyIterable([1,2,3]):
		print x

########################################
# OUTPUT:
# run func...
# 1
# run func...
# 2
# run func...
# 3
########################################
</code></pre>

<h2 id="生成器函数">生成器函数</h2>
<p>函数体中带有<code>yield</code>的函数几位生成器函数，调用生成器函数将返回一个生成器对象。
生成器对象也是一个可迭代对象。(可以调用<code>__iter__</code>函数)
也是一个迭代器对象。（可以调用<code>next</code>函数）</p>

<p>因此可以将某个类的<code>__iter__</code>方法实现为生成器函数来实现可迭代对象。</p>

<p>素数demo：</p>
<pre><code>class PrimeNumber:

	def __init__(self, start, stop):
		self.start = start
		self.stop = stop

	def is_prime(self, num):
		if num &lt; 2:
			return False
		for i in range(2, num):
			if num % i == 0:
				return False
		return True

	def __iter__(self):
		for i in range(self.start, self.stop + 1):
			if self.is_prime(i):
				yield i

for i in PrimeNumber(0, 100):
	print i 

</code></pre>

	<p><h3><a href="/posts/iter.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/git.html">
    Pro Git整理
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-04-03
  </div>
</h2>
<hr>
<p>学习自Pro Git文档，在此处进行梳理。</p>

<h2 id="一些未知概念">一些未知概念</h2>

<ul>
  <li>Git 对待数据更像是一个 快照流。</li>
  <li>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。</li>
</ul>

<h2 id="配置">配置</h2>

<p>git存在三个层级的配置级别，后一级别的配置项会覆盖前一层级的配置项。</p>
<ul>
  <li><code>git config --system</code> 系统级别，读写<code>/etc/gitconfig</code>文件。</li>
  <li><code>git config --global</code> 当前用户级别，读写<code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件。</li>
  <li><code>git config</code> 当前仓库级别，读写<code>.git/config</code>文件。</li>
</ul>

<h3 id="用户配置">用户配置</h3>
<p>只可填写一次，之后的任何一次commit都会使用该信息，不可修改。</p>

<pre><code>$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</code></pre>

<h3 id="文本编辑器">文本编辑器</h3>
<p>默认为vim。</p>

<pre><code>$ git config --global core.editor emacs
</code></pre>

<h3 id="检查配置信息">检查配置信息</h3>
<pre><code>$ git config --list
</code></pre>

<h2 id="命令">命令</h2>

<h3 id="状态概览">状态概览</h3>
<pre><code>$ git status -s
</code></pre>
<p>新添加的未跟踪文件前面有 ?? 标记。
新添加到暂存区中的文件前面有 A 标记。
修改过的文件前面有 M 标记。 
出现在右边的 M 表示该文件被修改了但是还没放入暂存区。
出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</p>

<h3 id="忽略文件">忽略文件</h3>
<p>通过创建<code>.gitignore</code>文件来选择无需纳入git中的文件。</p>
<pre><code># no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
</code></pre>

<h3 id="查看修改">查看修改</h3>
<pre><code>$ git diff 
</code></pre>
<p>工作区 vs 暂存区</p>
<pre><code>$ git diff --cached
</code></pre>
<p>暂存区 vs 仓库</p>

<h3 id="跳过暂存区">跳过暂存区</h3>
<pre><code>$ git commit -a -m "message"
</code></pre>
<p>可以将所有被跟踪的文件都提交到仓库中</p>

<h3 id="重命名文件">重命名文件</h3>
<p>在git中体现的操作为先删除再新建</p>

<h3 id="提交历史">提交历史</h3>
<pre><code>$ git log -p -2
$ git log --stat
</code></pre>
<p><code>-p</code>用来显示每次变动，<code>-2</code>显示近两次提交。
<code>--stat</code>用来显示所有被修改过文件的修改情况。
<code>--graph</code>用来显示分支合并情况。
<code>--pretty</code>指定显示格式。
<code>--graph</code>指定分支合并情况。</p>

<h3 id="撤销操作">撤销操作</h3>
<pre><code>$ git commit --amend
</code></pre>
<p>将暂存区里与上次提交历史合并并提交覆盖上次提交历史。</p>
<pre><code>$ git reset HEAD
</code></pre>
<p>将暂存区内容恢复到与仓库一致</p>

<h2 id="远程仓库">远程仓库</h2>
<pre><code>$ git remote -v
</code></pre>
<p>列出所有远程仓库列表</p>
<pre><code>$ git remote add &lt;shortname&gt; &lt;url&gt;
</code></pre>
<p>添加</p>
<pre><code>$ git fetch origin
</code></pre>
<p>拉取远程仓库的分支引用，可以随时合并或查看。</p>
<pre><code>$ git remote show origin 
</code></pre>
<p>查看远程分支信息</p>

<h2 id="git分支">GIT分支</h2>
<p>提交对象除了有指向快照的指针和作者邮箱等信息外，还具有指向父级提交对象的指针。
分支实际上为指向上一次提交对象的指针（可变指针）。
<code>HEAD</code>是一个特殊指针，指向当前所在的本地分支。
<code>git log --decorate</code>可查看各个分支指向的对象。
<code>git log --oneline --decorate --graph --all</code>查看分支分叉情况。</p>

<h3 id="解决bug模式本地">解决bug模式(本地)</h3>
<p>切换到线上分支-&gt;新建分支-&gt;修改bug-&gt;切换回线上分支-&gt;合并分支-&gt;返回工作分支</p>
<pre><code>$ git checkout -b issbug
$ git commit -a -m "fix bug"
$ git checkout master
$ git merge issbug  # git会自动选用合适的方式来合并分支，fast-forward或strage
$ git branch -d issbug
</code></pre>

<h3 id="分支管理">分支管理</h3>
<p><code>git branch --merged</code>已合并到当前分支的所有分支。
<code>git branch -D test</code>强制删除分支（不推荐）</p>

<h3 id="远程分支">远程分支</h3>
<p><code>origin/master</code>远程分支是不能移动的本地指针，指向对远程分支状态的引用。只要不与远程仓库连接，该指针就不会移动。
<code>git fetch origin</code>更新远程分支的引用，可以与本地分支分叉。
<code>git merge origin/master</code>将远程分支合并到当前分支。</p>

<ul>
  <li>跟踪分支：跟踪分支后在输入<code>git pull</code>后git可以知道到哪拉取并合并数据。
<code>git checkout -b serverfix origin/serverfix</code>建立本地分支并跟踪远程分支。
<code>git checkout --track origin/serverfix</code>等同。</li>
</ul>

<p><code>git branch -vv</code>获取分支和跟踪信息。</p>

<ul>
  <li>拉取
<code>git pull</code>相当于<code>git fetch</code>和<code>git merge</code>操作。</li>
</ul>

	<p><h3><a href="/posts/git.html">阅读全文 &raquo;</a></h3></p>
<hr>

<h2>
  <a href="/posts/sicp.html">
    SICP
  </a> 
  <div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-03-26
  </div>
</h2>
<hr>
<h3 id="过程和数据">过程和数据</h3>

<h3 id="替换">替换</h3>

<h3 id="正则序和应用序">正则序和应用序</h3>
<p>习题1.5
相当于函数参数的求值顺序</p>

<ul>
  <li>应用序：先求值再带入函数过程，可以防止多次运算的情况出现。lisp是应用序。</li>
  <li>正则序：先将函数过程展开再将参数替换进函数过程之中。</li>
</ul>

<h3 id="特殊函数">特殊函数</h3>
<p>习题1.6
编程语言中的<code>if</code>函数经过特殊处理，在<code>if</code>表达式计算结果为<code>true</code>后不会再继续计算之后的表达式和值。
自行构造的<code>new-if</code>函数不管内部如何，lisp总会计算所有表达式的值，之后将值替换到参数中（正则序也会无限展开），因此会进入无限递归中。</p>

<h3 id="递归计算过程和迭代计算过程">递归计算过程和迭代计算过程</h3>
<p>递归计算过程由一个推迟执行的运算链条刻画。
迭代计算过程则是通过状态变量描述的计算过程。</p>

<p>在树形递归算法中，递归计算过程的复杂度要远远高于迭代计算过程。</p>

	<p><h3><a href="/posts/sicp.html">阅读全文 &raquo;</a></h3></p>
<hr>


<!-- Pager indicator -->
<ul class="pager">
   
  <li class="next">
    <a href="/posts/page2/index.html">
      下一页 &rarr;
    </a>
  </li>
  
</ul>

        </div>
        <!-- Blog Sidebar Widgets Column -->
        <div class="col-md-4">
          <!-- Blog Categories Well -->
          <div class="well">
            <h4>
              栏目分类
            </h4>
            <div class="row">
                            <div class="col-lg-6">
                <ul class="list-unstyled">
                  <li>
                    <a href="/posts/work.html">
                      工作经验
                    </a>
                  </li>
                  <li>
                    <a href="/posts/study.html">
                      学习笔记
                    </a>
                  </li>
                  <li>
                    <a href="/posts/other.html">
                      随笔
                    </a>
                  </li>
                  <li>
                    <a href="/archives.html">
                      存档
                    </a>
                  </li>
                </ul>
              </div>
 
 
            </div>
            <!-- /.row -->
          </div>
		  <!-- Blog Recent Well -->
          <div class="well">
            <h4>
              最新文章
            </h4>
			<div class="row">
                            <div class="col-lg-12">
                <ul class="list-unstyled">
				
                  <li>
                    <a href="/posts/log.html">
                      为Spring Boot添加日志模块
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/mule.html">
                      通过MULE实现后端服务调用
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/bmpn.html">
                      BPMN2.0概念
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/socketio.html">
                      利用flask_socketio实现与前段的socket通信
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/shejimoshi.html">
                      大话设计模式Python实现
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/iter.html">
                      Python的迭代器，可迭代对象和生成器
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/git.html">
                      Pro Git整理
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/sicp.html">
                      SICP
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/rabbitmq.html">
                      RabbitMQ泛式
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/redis.html">
                      再看redis
                    </a>
                  </li>
				  
                </ul>
              </div> 
			</div>
          </div>		  
		  <!-- Blog Links Well -->
          <div class="well">
            <h4>
              友情链接
            </h4>
                        <ul class="list-unstyled">
              <li>
                <a href="http://www.ruanyifeng.com/blog/" target="_blank">
                  阮一峰的博客
                </a>
              </li>	
              <li>
                <a href="http://www.yinwang.org/" target="_blank">
                  王银的博客
                </a>
              </li>				  
            </ul>
 
          </div>
        </div>
      </div>
      <!-- /.row -->

      <!-- Footer -->
      <footer>
        <div class="row">
          <div class="col-lg-12">
                        <div style="text-align:center;margin-top:15px;">
				Copyright &copy; cuijintao.github.io, generated by Jekyll
				<br/>
            </div>
 
          </div>
          <!-- /.col-lg-12 -->
        </div>
        <!-- /.row -->
      </footer>
    </div>
    <!-- /.container -->
  </body>
</html>