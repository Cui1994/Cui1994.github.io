<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="再看redis - 崔金涛个人博客 - 作者:崔金涛"/> 
	<meta name="keywords" content="redis"/>
    <title>再看redis - 崔金涛个人博客</title>
    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet"/>
    <!-- Custom CSS -->
    <link href="/css/blog.css" rel="stylesheet"/>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media
    queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file://
    -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js">
      </script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js">
      </script>
    <![endif]-->
        <!-- jQuery Version 1.11.0 -->
    <script src="/js/jquery-1.11.0.js"> </script>
    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>
  </head>
  
  <body>
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">
              Toggle navigation
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
          </button>
          <a class="navbar-brand" href="/">
            首页
          </a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          		<ul class="nav navbar-nav">
			
				<li>
				  <a href="/posts/work.html">
					工作经验
				  </a>
				</li>
			
				<li>
				  <a href="/posts/study.html">
					学习笔记
				  </a>
				</li>
			
				<li>
				  <a href="/posts/other.html">
					随笔
				  </a>
				</li>
			
		</ul>  
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>
    <!-- Page Content -->
    <div class="container">
      <div class="row">
        <!-- Blog Entries Column -->
        <div class="col-md-8">
          <!-- Navi -->
<a href="/">首页</a>&nbsp;>&nbsp;<a href="/posts/study.html">学习笔记</a>&nbsp;>&nbsp;正文
<!-- Title -->
<h2>再看redis</h2>
<b>标签：</b><a href="/tags.html#redis"><i>redis</i></a>
<div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-03-01
</div>
<br/>

<!-- content -->
<div style="text-indent:2em;">
<p>之前只是将redis当做celery通信的中间件，并没有特别关注其独有特性。再回看redis，其许多特性可以应用到不同的场景中，且效率比一般关系型数据库要高。</p>

<h2 id="几种数据类型的优势">几种数据类型的优势</h2>
<p>redis作为一种NoSQL数据库，自然可以适应高并发和海量数据的存储，同样以key作为检索的唯一索引，不能对复杂的逻辑关系提供很好的支持。但其被广泛认作key-value型存储结构的数据库，其实有失偏颇。redis除了string是典型的key-value结构外，其余数据结构都有其独特应用。</p>

<h3 id="list">list</h3>
<p>redis的list链表结构，由于其有序性，在链表的两头插入和删除元素都十分高效，时间复杂度为O(1)。但在链表中间插入和删除数据效率会下降，时间复杂度为O(N)。</p>

<h3 id="hash">hash</h3>
<p>hash结构是具有string类型的field-value的映射表，适合存储对象信息，hash中的字段较少时占用内存也比较低。</p>

<h3 id="set">set</h3>
<p>set集合中的元素没有顺序，不允许重复，增查更新的时间复杂度均为O(1)，可以再服务器端进行求并集差集运算，效率很高。</p>

<h3 id="ordered-set">ordered set</h3>
<p>同set集合一样，只不过对每个元素都结合了一个score关联进行排序，实现增删改的操作非常迅速，时间复杂度为O(logN)，这在其他关系型数据库中是比较难实现的。</p>

<h3 id="应用场景">应用场景</h3>
<p>这里模拟了一些可以用redis解决的场景。</p>

<ul>
  <li>典型Pub-Sub场景</li>
</ul>

<p>这是redis可以实现的最为典型的场景</p>

<pre><code class="language-python"># pub.py

import redis
r = redis.Redis(host='localhost', port=6379)
r.publish('en', 'hello, world')
</code></pre>
<pre><code># sub.py

import redis
r = redis.Redis(host='localhost', port=6379)
pubsub = r.pubsub()
pubsub.subscribe('en')
for item in pubsub.listen():
    print item
</code></pre>

<ul>
  <li>最近登录列表</li>
</ul>

<p>模拟队列并保持队列内元素数目为定值。</p>

<pre><code>uid = randint(0, 9)
ret = r.lpush('login:last_login_times', uid)
ret = r.ltrim('login:last_login_times', 0, 4)
last_login_list = r.lrange('login:last_login_times', 0, 4)
print last_login_list
</code></pre>

<ul>
  <li>生产者消费者模型</li>
</ul>

<p>生产者推送消息，消费者执行，生成备份消息队列防止消息丢失。</p>

<pre><code>if r.llen('message') &lt; 2:
	r.lpush('message', 1,2,3)
msg = randint(0, 9)
r.lpush('message', msg)
r.rpoplpush('message', 'message_backup')
print r.lrange('message', 0, -1)
print r.lrange('message_backup', 0, 5)
</code></pre>

<ul>
  <li>积分排行榜</li>
</ul>

<p>玩家分数变化时用zadd更新玩家分数，再用zrange获取积分top信息。</p>

<pre><code class="language-python">if r.zcard('new_login_times') == 0:
	r.zadd('new_login_times', 'Bob', 1)
	r.zadd('new_login_times', 'Jack', 1)
	r.zadd('new_login_times', 'Crool', 1)

uid = randint(0, 2)
name = ['Bob', 'Jack', 'Crool'][uid]
print name
ret = r.zincrby('new_login_times', name, 1)
#login_times_list = r.zrevrange('new_login_times', 1, 3)
print r.zrevrange('new_login_times', 0, -1, withscores=True)
</code></pre>

<ul>
  <li>共同关注
利用set的高效intersections命令，类似的还有suninostore求并集命令。</li>
</ul>

<pre><code>r.sadd('s1', 'a', 'b', 'c', 'd')
r.sadd('s2', 'b', 'c', 'd', 'e')
r.sadd('s3', 'c', 'd', 'e', 'f')
r.sinterstore('result', 's1', 's2', 's3')
print r.smembers('result')
r.delete('s1', 's2', 's3', 'result')
</code></pre>

<ul>
  <li>Master/Slave模型
利用list可以很容易实现分布式中的Master/Slave模型。</li>
</ul>

<pre><code class="language-python"># RedusQueue.py

import redis

class RedisQueue(object):
    """Simple Queue with Redis Backend"""
    def __init__(self, name, namespace='queue', **redis_kwargs):
        """The default connection parameters are: host='localhost', port=6379, db=0"""
        self.__db= redis.Redis(**redis_kwargs)
        self.key = '%s:%s' %(namespace, name)

    def qsize(self):
        """Return the approximate size of the queue."""
        return self.__db.llen(self.key)

    def empty(self):
        """Return True if the queue is empty, False otherwise."""
        return self.qsize() == 0

    def put(self, item):
        """Put item into the queue."""
        self.__db.rpush(self.key, item)

    def get(self, block=True, timeout=None):
        """Remove and return an item from the queue.

        If optional args block is true and timeout is None (the default), block
        if necessary until an item is available."""
        if block:
            item = self.__db.blpop(self.key, timeout=timeout)
        else:
            item = self.__db.lpop(self.key)

        if item:
            item = item[1]
        return item

    def get_nowait(self):
        """Equivalent to get(False)."""
        return self.get(False)
</code></pre>

<pre><code># master.py

from RedisQueue import RedisQueue

rq = RedisQueue('test')
for i in range(30):
	rq.put(i)
print rq.qsize()
</code></pre>

<pre><code># slave.py

import time
from RedisQueue import RedisQueue

rq = RedisQueue('test')
while not rq.empty():
	print rq.get()
	time.sleep(1)
</code></pre>

<h2 id="redis事务">redis事务</h2>
<p>redis事务被MULTI/EXEC/DISCARD/WATCH囊括，实际是串行顺序执行，执行期间redis不会再为客户端提供任何服务，从而保证事务的原子执行。</p>

<p>EXEC/DISCARD类似于关系型数据库中的COMMIT/ROLLBACK语句。若在一次事务中发生错误redis将回滚所有操作。</p>

<p>WATCH可以实现CAS即check-and-set锁。若在WATCH中监控的值发生改变，事务中的后续操作都不会被执行。这一特性可以很好地应用于多用户同时请求一个redis值时防止值得结果不一致。</p>

<h2 id="redis主从复制">redis主从复制</h2>
<p>redis可以很好地实现Master/Slave模型，此外其还有许多独有特性。</p>

<ol>
  <li>同一个Master可以为多个Slave服务。</li>
  <li>Slave和Slave之间也可以实现连接和同步请求。</li>
  <li>S响应M是非阻塞的，期间M仍可以为客户端提供请求。</li>
  <li>S之间的同步也是非阻塞的</li>
  <li>可以设置S来实现只读的用户响应和保存数据的任务，以降低M的负荷。</li>
</ol>

<p>具体实现：</p>
<pre><code>$ redis-server --port 6380 &amp;
$ redis-cli -p 6380
127.0.0.1:6380&gt; slaveof 127.0.0.1 6379
</code></pre>
<p>这样就实现了主从复制，服务关闭后这种关系也消失，若想永久保存需要修改配置文件。</p>

<h2 id="redis持久化">redis持久化</h2>
<p>redis有三种（实际上是两种）持久化机制，快照（RDB)和追加式文件（AOF）。</p>

<p>RDB会在固定时间将数据集快照写入磁盘，每一次写入都会覆盖之前的文件，因此只存在一个文件。方便归档和备份，但有数据丢失的危险。</p>

<p>AOF则会在每次修改后将命令追加到AOF文件中，而且有redis-check-aof工具来解决命令执行一半宕机的问题。是一种非常可靠的持久化方式，缺点是速度慢，文件多。</p>

<p>若有需求需要修改配置文件，此处不赘述。</p>


</div>

<br/>
<b>原创文章，转载请注明出处！</b>
<br/>
<b>本文链接：</b><a href="http://localhost:4000/posts/redis.html" title="">http://localhost:4000/posts/redis.html</a>

<!-- next and previous -->
<div style="margin-top:15px; margin-bottom:10px">
  
  <span class="next">
    上篇：
    <a href="/posts/zhibotong.html">
      关于直播通
    </a>
  </span>
   
  
  <div style="float:right">
  <span class="prev" >
    下篇：
    <a href="/posts/rabbitmq.html">
      RabbitMQ泛式
    </a>
  </span>
  </div>
  
</div>
<hr>
<!-- Blog Comments -->
<div class="media">
   
</div>
        </div>
        <!-- Blog Sidebar Widgets Column -->
        <div class="col-md-4">
          <!-- Blog Categories Well -->
          <div class="well">
            <h4>
              栏目分类
            </h4>
            <div class="row">
                            <div class="col-lg-6">
                <ul class="list-unstyled">
                  <li>
                    <a href="/posts/work.html">
                      工作经验
                    </a>
                  </li>
                  <li>
                    <a href="/posts/study.html">
                      学习笔记
                    </a>
                  </li>
                  <li>
                    <a href="/posts/other.html">
                      随笔
                    </a>
                  </li>
                  <li>
                    <a href="/archives.html">
                      存档
                    </a>
                  </li>
                </ul>
              </div>
 
 
            </div>
            <!-- /.row -->
          </div>
		  <!-- Blog Recent Well -->
          <div class="well">
            <h4>
              最新文章
            </h4>
			<div class="row">
                            <div class="col-lg-12">
                <ul class="list-unstyled">
				
                  <li>
                    <a href="/posts/log.html">
                      为Spring Boot添加日志模块
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/mule.html">
                      通过MULE实现后端服务调用
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/bmpn.html">
                      BPMN2.0概念
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/socketio.html">
                      利用flask_socketio实现与前段的socket通信
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/shejimoshi.html">
                      大话设计模式Python实现
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/iter.html">
                      Python的迭代器，可迭代对象和生成器
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/git.html">
                      Pro Git整理
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/sicp.html">
                      SICP
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/rabbitmq.html">
                      RabbitMQ泛式
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/redis.html">
                      再看redis
                    </a>
                  </li>
				  
                </ul>
              </div> 
			</div>
          </div>
        </div>
      </div>
      <!-- /.row -->

      <!-- Footer -->
      <footer>
        <div class="row">
          <div class="col-lg-12">
                        <div style="text-align:center;margin-top:15px;">
				Copyright &copy; cuijintao.github.io, generated by Jekyll
				<br/>
            </div>
 
          </div>
          <!-- /.col-lg-12 -->
        </div>
        <!-- /.row -->
      </footer>
    </div>
    <!-- /.container -->
  </body>

</html>
