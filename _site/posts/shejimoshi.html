<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="大话设计模式Python实现 - 崔金涛个人博客 - 作者:崔金涛"/> 
	<meta name="keywords" content="设计模式"/>
    <title>大话设计模式Python实现 - 崔金涛个人博客</title>
    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet"/>
    <!-- Custom CSS -->
    <link href="/css/blog.css" rel="stylesheet"/>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media
    queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file://
    -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js">
      </script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js">
      </script>
    <![endif]-->
        <!-- jQuery Version 1.11.0 -->
    <script src="/js/jquery-1.11.0.js"> </script>
    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>
  </head>
  
  <body>
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">
              Toggle navigation
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
          </button>
          <a class="navbar-brand" href="/">
            首页
          </a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          		<ul class="nav navbar-nav">
			
				<li>
				  <a href="/posts/work.html">
					工作经验
				  </a>
				</li>
			
				<li>
				  <a href="/posts/study.html">
					学习笔记
				  </a>
				</li>
			
				<li>
				  <a href="/posts/other.html">
					随笔
				  </a>
				</li>
			
		</ul>  
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>
    <!-- Page Content -->
    <div class="container">
      <div class="row">
        <!-- Blog Entries Column -->
        <div class="col-md-8">
          <!-- Navi -->
<a href="/">首页</a>&nbsp;>&nbsp;<a href="/posts/study.html">学习笔记</a>&nbsp;>&nbsp;正文
<!-- Title -->
<h2>大话设计模式Python实现</h2>
<b>标签：</b><a href="/tags.html#设计模式"><i>设计模式</i></a>
<div class="post-date">
	<span class="glyphicon glyphicon-time"></span>
	2017-04-13
</div>
<br/>

<!-- content -->
<div style="text-indent:2em;">
<p>学习自大话设计模式，将其C#语言实现翻译为Python，同时参照此系列博客：<a href="http://www.jianshu.com/p/84ae207ccaf7">Python设计模式</a> 加深理解。</p>

<h2 id="1简单工厂模式">1.简单工厂模式</h2>

<p>面向对象目标：</p>

<ul>
  <li>可维护：只需要改动需求制定功能的类或模块</li>
  <li>可复用：可以用在不同的环境下</li>
  <li>可扩展：增加功能只需要增加相应的模块</li>
  <li>灵活性好：可以任意组合功能</li>
</ul>

<p>耦合性：更改一个功能不需要接触其他功能（即使功能都是相似的），考虑通过封装、继承和多态将耦合性降低。</p>

<p>根据需求实例化要实例的对象（这些对象可能均继承自同一基类）。</p>

<p>缺点：违反了高内聚职责分配原则 <a href="http://www.cnblogs.com/sevenyuan/archive/2010/03/05/1678730.html">职责分配原则</a></p>

<p>计算器实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
import re=

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a / self.b
		return result

class OperationFactory(object):
	def create_operation(self, operation, a, b):
		if operation == '+':
			return AddOperation(a, b)
		elif operation == '-':
			return SubtractOperation(a, b)
		elif operation == '*':
			return MultiplicationOperation(a, b)
		elif operation == '/':
			return DivisionOperation(a, b)
		else:
			raise ValueError

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][3]
		b = int(items[0][2])
		print OperationFactory().create_operation(operation, a, b).calculate_result()
	except:
		print 'Wrong Input.'
</code></pre>

<h2 id="2策略模式">2.策略模式</h2>

<p>将一系列算法家族封装，算法家族完成的是同一类功能的不同实现（都是用来解决同一个问题的，只是不同情况需要应用不同的算法），降低了客户端和算法类之间的耦合。</p>

<p>缺点：增加策略时仍然需要到<code>Context</code>类中增加一个新的判断分支。</p>

<p>超市活动实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Strategy(object):
	# 抽象算法类
	def algorithm_interface(self):
		raise NotImplementedError()

class NormalStrategy(Strategy):

	def algorithm_interface(self, money):
		return money

class RebateStrategy(Strategy):

	def __init__(self, rebate):
		self.rebate = rebate

	def algorithm_interface(self, money):
		return money*self.rebate

class ReturnStrategy(Strategy):

	def __init__(self, each_money, return_money):
		self.each_money = each_money
		self.return_money = return_money

	def algorithm_interface(self, money):
		return money-(money/self.each_money)*self.return_money

class Context(object):
	# 上下文，封装策略的实现细节
	def __init__(self, strategy_type):
		if strategy_type == 'normal':
			self.strategy = NormalStrategy()
		elif strategy_type == '0.8 rebate':
			self.strategy = RebateStrategy(0.8)
		elif strategy_type == '300 return 100':
			self.strategy = ReturnStrategy(300, 100)

	def context_interface(self, money):
		return self.strategy.algorithm_interface(money)

if __name__ == '__main__':
	money = int(raw_input('Enter money:'))
	strategy_type = raw_input('Enter strategy type:')
	print Context(strategy_type).context_interface(money)
</code></pre>

<h2 id="3单一职责原则">3.单一职责原则</h2>

<p>类的功能要尽量单一——利于解耦</p>

<h2 id="4开放封闭原则">4.开放封闭原则</h2>

<p>最扩展开放，最修改封闭。（写好的类尽量不要去改动他）
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
在最开始写代码时，假定变化不会发生，当变化发生之后，就要创建抽象来隔离变化。</p>

<h2 id="5依赖倒转原则">5.依赖倒转原则</h2>

<p>抽象不应该依赖于细节，细节应该依赖于抽象。
要对接口编程，而不要对实现编程。
里氏代换原则：子类必须能够替换掉他们的父类型。</p>

<h2 id="6装饰模式">6.装饰模式</h2>

<p>把每个需要装饰的功能放在单独的类中，需要使用新功能时只需要用装饰的类去包装原有的核心类，将类的核心职责和装饰功能分开，避免增加核心类的复杂度。</p>

<p>python自带的装饰器也是一种装饰模式的实现。</p>

<p>穿衣服实例</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
class Person(object):

	def __init__(self):
		self.name = ''

	def set_name(self, name):
		self.name = name

	def show(self):
		print u'装扮的{0}'.format(self.name)

class Finery(Person):

	def set_decorate(self, component):
		self.component = component

	def show(self):
		if self.component:
			self.component.show()

class TShirts(Finery):

	def show(self):
		print u'T-shirt.'
		super(TShirts, self).show()

class BigTrouser(Finery):

	def show(self):
		print u'Big-Trouser.'
		super(BigTrouser, self).show()

if __name__ == '__main__':
	xiao_ming = Person()
	xiao_ming.set_name('xiaoMing')

	print u'第一种装扮：'
	t_shirt = TShirts()
	big = BigTrouser()

	t_shirt.set_decorate(xiao_ming)
	big.set_decorate(t_shirt)

	big.show()
</code></pre>

<h2 id="7代理模式">7.代理模式</h2>

<p>用代理对象去调用真是对象的接口，可以完成一些额外的事。</p>

<p>代理和真是对象公用一个接口（继承自同一基类）。代理此接口的真正目的是调用真实对象的接口。</p>

<p>代码实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Subject(object):

	def request(self):
		raise NotImplementedError

class RealSubject(Subject):

	def request(self):
		print 'Real Request.'

class ProxySubject(Subject):

	def __init__(self):
		self.real = RealSubject()

	def request(self):
		self.real.request()

if __name__ == '__main__':
	proxy = ProxySubject()
	proxy.request()
</code></pre>

<h2 id="8工厂方法模式">8.工厂方法模式</h2>

<p>将简单工厂模式实例化类的时机延后到工厂子类进行，克服了简单工厂模式违背封闭原则的缺点。</p>

<p>但其仍有缺点：判断分支从工厂中转移到了客户端中进行。相当于绕了一圈又绕回来了。</p>

<p>计算器实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-
import re

class Operation(object):
	def __init__(self, a, b):
		self.a = a
		self.b = b

	def calculate_result(self):
		result = 0
		return result

class AddOperation(Operation):
	def calculate_result(self):
		result = self.a + self.b
		return result

class SubtractOperation(Operation):
	def calculate_result(self):
		result = self.a - self.b
		return result

class MultiplicationOperation(Operation):
	def calculate_result(self):
		result = self.a * self.b
		return result

class DivisionOperation(Operation):
	def calculate_result(self):
		result = self.a // self.b
		return result

class IFactory(object):
	def create_operation(self, a, b):
		raise NotImplementedError

class AddFactory(IFactory):
	def create_operation(self, a, b):
		return AddOperation(a, b)

class SubFactory(IFactory):
	def create_operation(self, a, b):
		return SubtractOperation(a, b)

class MulFactory(IFactory):
	def create_operation(self, a, b):
		return MultiplicationOperation(a, b)

class DivFactory(IFactory):
	def create_operation(self, a, b):
		return DivisionOperation(a, b)

if __name__ == '__main__':
	input_string = raw_input('Enter your operation such as \'10+11=\':')
	pattern = re.compile(r'(\d+)(\+|\-|\*|\/)(\d+)')
	items = pattern.findall(input_string)
	try:
		a = int(items[0][0])
		operation = items[0][1]
		b = int(items[0][2])
		if operation == '+':
			oper = AddFactory().create_operation(a, b)
		elif operation == '-':
			oper = SubFactory().create_operation(a, b)
		elif operation == '*':
			oper = MulFactory().create_operation(a, b)
		elif operation == '/':
			oper = DivFactory().create_operation(a, b)
		print oper.calculate_result()
	except:
		print 'Wrong Input.'
</code></pre>

<h2 id="9原型模式">9.原型模式</h2>

<p>从一个对象再创建一个可定制的对象，而且不需要知道任何创建的细节。（不需要再手动实例化一个新实例）
tip：这里涉及了深浅拷贝的概念。</p>

<p>优点：隐藏创建细节，提高性能。（不需要每次都调用构造函数）</p>

<pre><code class="language-python">import copy

class Book(object):
	def __init__(self, name, authors, price):
		self.name = name
		self.authors = authors
		self.price = price

	def clone(self, **kwargs):
		book_copy = copy.deepcopy(self)
		book_copy.__dict__.update(**kwargs)
		return book_copy

book1 = Book('Python', ['Tom', 'Jack'], 10)
book2 = book1.clone(price=20)
print book2.__dict__
# {'price': 20, 'name': 'Python', 'authors': ['Tom', 'Jack']}
</code></pre>

<h2 id="10-模板方法模式">10. 模板方法模式</h2>

<p>比较常见的设计模式，制定一种工作流或算法的特定骨架而将具体实现放到子类中。</p>

<pre><code class="language-python">class FatherClass(object):
    def tempmethod(self):
        print "first step: red"
        self.childmethod()
        print "third step: blue"
        
    def childmethod(self):
        raise NotImplementedError
    
class ChildClass1(FatherClass):
    def childmethod(self):
        print "second step: green"
        
class ChildClass2(FatherClass):
    def childmethod(self):
        print "second step: yellow"

</code></pre>

<h2 id="11迪米特法则">11.迪米特法则</h2>

<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p>

<p>强调类之间的松耦合。耦合度越低，越利于复用。</p>

<h2 id="12外观模式">12.外观模式</h2>

<p>给一组系统方法一个统一的接口，提供了一个更高层的接口方法。</p>

<p>有点类似代理模式。</p>

<pre><code class="language-python">class ModuleOne(object):
    def Create(self):
        print 'create module one instance'

    def Delete(self):
        print 'delete module one instance'

class ModuleTwo(object):
    def Create(self):
        print 'create module two instance'

    def Delete(self):
        print 'delete module two instance'

class Facade(object):
    def __init__(self):
        self.module_one = ModuleOne()
        self.module_two = ModuleTwo()

    def create_module_one(self):
        self.module_one.Create()

    def create_module_two(self):
        self.module_two.Create()

    def create_both(self):
        self.module_one.Create()
        self.module_two.Create()

    def delete_module_one(self):
        self.module_one.Delete()

    def delete_module_two(self):
        self.module_two.Delete()

    def delete_both(self):
        self.module_one.Delete()
        self.module_two.Delete()
</code></pre>

<h2 id="13建造者模式">13.建造者模式</h2>

<p>讲一个复杂对象的构建和他的表示分离，这样可以用同样的构建方式创建不同的表示。</p>

<p>优点：对象内部的构建顺序是稳定的，建造者隐藏了产品如何组装。</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Builder(object):
# 抽象建造者类，也可以说是产品类
	def part1(self):
		raise NotImplementedError

	def part2(self):
		raise NotImplementedError

class Builder1(object):

	def part1(self):
		print 'builder1 part1'

	def part2(self):
		print 'builder1 part2'

class Builder2(object):

	def part1(self):
		print 'builder2 part1'

	def part2(self):
		print 'builder2 part2'

class Director(object):

	def build(self, builder):
		builder.part1()
		builder.part2()

if __name__ == '__main__':
	builder = Builder1()
	director = Director()

	director.build(builder)
</code></pre>

<p>也可以将<code>Director</code>的代码已到<code>Builder</code>类中，实现模板方法模式。</p>

<pre><code class="language-python">class Builder(object):
    # ···
    def build(self):
        self.part1()
        self.part2()
</code></pre>

<h2 id="14观察者模式">14.观察者模式</h2>

<p>又称作Pub/Sub模式
定义了一种一对多的依赖关系，让众多观察者可以同时关注某一主题，当主题发生变化时每个观察者都会更新自己的状态。
许多MQ都是通过这一模式实现的。</p>

<pre><code class="language-python">class Topic(object):

	def __init__(self):
		self.obs = []

	def attach(self, observer):
		self.obs.append(observer)

	def detach(self, observer):
		self.obj.remove(observer)

	def notify(self, message):
		for observer in self.obs:
			observer.update(message)

class Observer(object):

	def update(self, message):
		raise NotImplementedError

class ConcreteObserver(Observer):

	def update(self, message):
		print message

if __name__ == '__main__':
	topic = Topic()
	ob1 = ConcreteObserver()
	ob2 = ConcreteObserver()
	topic.attach(ob1)
	topic.attach(ob2)
	topic.notify("hello")

</code></pre>

<h2 id="15抽象工厂模式">15.抽象工厂模式</h2>

<p>创建具有一定功能的产品实现时，需要先创建具体的工厂类，再由工厂类创建具有特定实现的产品对象。</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class IUser(object):

	def insert_user(self, user):
		raise NotImplementedError

	def get_user(self, userid):
		raise NotImplementedError

class IRole(object):
	def insert_role(self, role):
		raise NotImplementedError

	def get_role(self, roleid):
		raise NotImplementedError

class SqlServerUser(IUser):

	def insert_user(self, user):
		print u"在SQL Server中给User表增加一条记录."

	def get_user(self, userid):
		print u"在SQL Server中拿到一条uer信息。"

class SqlServerRole(IRole):
	def insert_role(self, role):
		print u"在SQL Server中给Role表增加一条记录"

	def get_role(self, roleid):
		print u"在SQL Server中拿到一条role记录"

# 产品类        
class AccessUser(IUser):
	def insert_user(self, user):
		print u"在Access中给User表增加一条记录."

	def get_user(self, userid):
		print u"在Access中拿到一条uer信息。"

class AccessRole(IUser):
	def insert_role(self, role):
		print u"在Access中给Role表增加一条记录"

	def get_role(self, roleid):
		print u"在Access中拿到一条role记录"

# 抽象工厂类
class IFactory(object):
	def create_user(self):
		raise NotImplementedError

	def create_role(self):
		raise NotImplementedError

# 具体工厂类
class SqlServerFactory(IFactory):

	def create_user(self):
		return SqlServerUser()

	def create_role(self):
		return SqlServerRole()

# 具体工厂类
class AccessFactory(IFactory):

	def create_user(self):
		return AccessUser()

	def create_role(self):
		return AccessRole()

class User(object):

	def __init__(self, id):
		self.id = id

class Role(object):

	def __init(self, id):
		self.id = id


if __name__ == '__main__':

	user = User(1)
	factory = SqlServerFactory()
	iu = factory.create_user()

	iu.insert_user(user)
	iu.get_user(1)
</code></pre>

<p>也可以考虑用引入简单工厂加反射进行优化。</p>

<h2 id="16状态模式">16.状态模式</h2>

<p>对象的行为取决于它的状态，并且他需要在运行时刻根据状态改变它的行为。</p>

<p>此时会产生大量判断语句，使用状态模式可以消除这些判断语句，降低耦合性。</p>

<p>工作实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class State(object):
	def write_program(work):
		raise NotImplementedError

class ForenoonState(State):
	def write_program(self, wrok):
		if work.hour &lt; 12:
			print u"当前时间: {}点， 上午工作，精神百倍".format(work.hour)
		else:
			wrok.set_state(NoonState())
			work.write_program()

class NoonState(State):
	def write_program(self, work):
		if work.hour &lt; 13:
			print u"当前时间：{}点， 饿了，午饭； 困了，午休".format(work.hour)
		else:
			work.set_state(AfternoonState())
			work.write_program()

class AfternoonState(State):
	def write_program(self, work):
		if work.task_finished:
			work.set_state(RestState())
		if work.hour &lt; 17:
			print u"当前时间：{}点， 下午状态不错，继续努力".format(work.hour)
		else:
			work.set_state(EveningState())
			work.write_program()

class EveningState(State):
	def write_program(self, work):
		print u"当前时间： {}点， 又要加班了！".format(work.hour)

class RestState(State):
	def write_program(self, work):
		print u"当前时间： {}点， 下班回家啦".format(work.hour)

class Work(object):
	def __init__(self):
		self.current = ForenoonState()
		self.hour = 9
		self.task_finished = False

	def set_hour(self, hour):
		self.hour = hour

	def set_finished(self, finished):
		self.set_finished = finished

	def set_state(self, state):
		self.current = state

	def write_program(self):
		self.current.write_program(self)

if __name__ == "__main__":
	work = Work()
	work.set_hour(9)
	work.write_program()
</code></pre>

<h2 id="17适配器模式">17.适配器模式</h2>

<p>当一个类的功能和数据相同而接口不同时，需要适配器模式充当翻译角色。</p>

<p>缺点：亡羊补牢</p>

<p>NBA翻译实例：</p>

<pre><code class="language-python"># -*- coding:utf-8 -*-

class Player(object):
	def __init__(self, name):
		self.name = name

	def attack(self):
		print u"{} 进攻".format(self.name)

	def defense(self):
		print u"{} 防守".format(self.name)

class ForeignPlayer(object):

	def __init__(self, name):
		self.name = name

	def jingong(self):
		print u"{} 进攻".format(self.name)

	def fangshou(self):
		print u"{} 防守".format(self.name)

class Translator(Player):

	def __init__(self, name):
		super(Translator, self).__init__(name)
		self.fp = ForeignPlayer(self.name)

	def attack(self):
		self.fp.jingong()

	def defense(self):
		self.fp.fangshou()

if __name__ == '__main__':
	b = Player("Bdier")
	b.attack()

	m = Player("Mical")
	m.attack()

	ym = Translator("YaoMing")
	ym.attack()
	ym.defense()
</code></pre>


</div>

<br/>
<b>原创文章，转载请注明出处！</b>
<br/>
<b>本文链接：</b><a href="http://localhost:4000/posts/shejimoshi.html" title="">http://localhost:4000/posts/shejimoshi.html</a>

<!-- next and previous -->
<div style="margin-top:15px; margin-bottom:10px">
  
  <span class="next">
    上篇：
    <a href="/posts/iter.html">
      Python的迭代器，可迭代对象和生成器
    </a>
  </span>
   
  
  <div style="float:right">
  <span class="prev" >
    下篇：
    <a href="/posts/socketio.html">
      利用flask_socketio实现与前段的socket通信
    </a>
  </span>
  </div>
  
</div>
<hr>
<!-- Blog Comments -->
<div class="media">
   
</div>
        </div>
        <!-- Blog Sidebar Widgets Column -->
        <div class="col-md-4">
          <!-- Blog Categories Well -->
          <div class="well">
            <h4>
              栏目分类
            </h4>
            <div class="row">
                            <div class="col-lg-6">
                <ul class="list-unstyled">
                  <li>
                    <a href="/posts/work.html">
                      工作经验
                    </a>
                  </li>
                  <li>
                    <a href="/posts/study.html">
                      学习笔记
                    </a>
                  </li>
                  <li>
                    <a href="/posts/other.html">
                      随笔
                    </a>
                  </li>
                  <li>
                    <a href="/archives.html">
                      存档
                    </a>
                  </li>
                </ul>
              </div>
 
 
            </div>
            <!-- /.row -->
          </div>
		  <!-- Blog Recent Well -->
          <div class="well">
            <h4>
              最新文章
            </h4>
			<div class="row">
                            <div class="col-lg-12">
                <ul class="list-unstyled">
				
                  <li>
                    <a href="/posts/log.html">
                      为Spring Boot添加日志模块
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/mule.html">
                      通过MULE实现后端服务调用
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/bmpn.html">
                      BPMN2.0概念
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/socketio.html">
                      利用flask_socketio实现与前段的socket通信
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/shejimoshi.html">
                      大话设计模式Python实现
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/iter.html">
                      Python的迭代器，可迭代对象和生成器
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/git.html">
                      Pro Git整理
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/sicp.html">
                      SICP
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/rabbitmq.html">
                      RabbitMQ泛式
                    </a>
                  </li>
				
                  <li>
                    <a href="/posts/redis.html">
                      再看redis
                    </a>
                  </li>
				  
                </ul>
              </div> 
			</div>
          </div>
        </div>
      </div>
      <!-- /.row -->

      <!-- Footer -->
      <footer>
        <div class="row">
          <div class="col-lg-12">
                        <div style="text-align:center;margin-top:15px;">
				Copyright &copy; cuijintao.github.io, generated by Jekyll
				<br/>
            </div>
 
          </div>
          <!-- /.col-lg-12 -->
        </div>
        <!-- /.row -->
      </footer>
    </div>
    <!-- /.container -->
  </body>

</html>
