---
layout: post
category: "工作"
title:  "python在一般互联网业务中的应用（五） api层"
tags: [python]
---

提供HTTP服务的api层负责处理以下任务：
- 管理路由
- 获取并检查参数
- 将请求分发给相应的逻辑层 (简单的函数调用，略)
- 包装返回数据 (由工具类中的trans方法完成)
- 处理错误
api层的代码应简单清晰，甚至你的每个路由对应的函数都“长得”差不多，这部分代码不应掺杂任何逻辑处理，他要做的仅仅是将请求指向相应的逻辑类去处理。

# 管理路由

`Flask`较为简单，一般来说，要实现基本功能，只需在`api`目录下生成蓝图和视图函数，在`app.py`中注册蓝图，并添加404和500的处理即可。

```Python
from my_project.api.student import student_api

logger = logging.getLogger(__name__)

app = Flask(__name__)

@app.errorhandler(404)
def page_not_found(error):
    logger.exception('api not found: {}'.format(error))
    return 'This api is not exits.', 404


@app.errorhandler(500)
def server_error(error):
    logger.exception('server error: {}'.format(error))
    return 'Server error.', 500

app.register_blueprint(student_api, url_prefix='/student')

```

除此之外， 需要考虑与前端交互的跨域请求访问情况，这部分可依赖`CORS`实现。

```
cors = CORS(app, resources={r"/student/*": {"origins": "*"},}, supports_credentials=True)
```

当然，你还需要测试你的server是否可用的ping路由和默认路由。

```
@app.route('/ping')
@cross_origin()
def ping():
    return True

@app.route('/')
def hello_world():
    return u'Hello World!'
```

更进一步，可以借助钩子在请求前后完成一些额外的工作，例如判断前端（或app）的设备类型，记录一层请求的用时等，也可在这部分完成。

```
@app.before_request
def before_request():
    stat_ctx = dict()
    stat_ctx['method'] = request.method
    stat_ctx['url'] = request.url
    stat_ctx['start_time'] = time.time()
    request.stat_ctx = stat_ctx


@app.after_request
def after_request(response):
    stat_ctx = request.stat_ctx
    stat_ctx['end_time'] = time.time()
    logger.info(u'[stat_ctx] my_project: {method} {url} response in {time}'.format(method=stat_ctx['method'],
                                                                                   url=stat_ctx['url'],
                                                                                   time=stat_ctx['end_time'] - stat_ctx[
                                                                                       'start_time']))
    return response
```

至此，`app.py`的功能基本完整，其他涉及具体业务的api可以在`my_project/api`目录下新开蓝图。

# 获取并检查参数

HTTP协议在请求中添加参数有多种方式，相应的，flask的`Request`对象会提供多种获取参数的方式。在获取参数时需要弄清楚参数传递的具体类型，否则不能正确拿到参数。

- URL参数 将参数放在url中，可通过`request.args.get('key')`获取。
- Form-data 通过HTML的`form`标签传递参数，通过`request.form.get('key')`获取。
- x-www-form-urlencoded 与From-data类似，只是请求方式有区别。获取参数方式相同。
- application/json 最常见的参数传递方式，通过`request.json.get('key')`获取。

flask获取请求参数的方法有的基于`werkzueg`的`BaseRequest`对象实现，有的自己做了封装，使用时注意参照源码。这里为了方便，可以在工具类中加入参数的部分。

```
# util/params.py

import json

def get_params(request):
    """获取request中的参数"""
    params = dict()
    if request.values:
        for k in request.values:
            params[k] = request.values.get(k)
    if request.get_data():
        params.update(json.loads(request.get_data()))
    return params
```

获取列表数据也可以构建相应方法，或在代码中直接获取，这里不再赘述。
有一点需要注意，`get_data`方法获取参数时从`stream`中读取数据，而`request`对象中很多方法在调用之后会清空`stream`，导致无法通过`get_data`拿到数据，尽量将其作为兜底逻辑而不是首选。

# 处理错误

如果没有外部rpc调用，可以在`util/response.py`中增加捕捉错误的装饰器即可，这里需要将所有的错误包住，记录日志，并返回相应的错误码和信息。如果存在外部rpc调用，则可以在每个`rpc`目录下新增相应的错误捕获代码。

```
# util/response.py

from my_project.exc import (
    ProjectUserException,
    ProjectSystemException,
    ProjectUnknownException
)

def custom_exception_capture(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except (ProjectUserException, ProjectSystemException) as e:
            logger.error(e)
            return response(e.code, e.message or
                            ResponseCodeExplain[ResponseCode.SYSTEM_ERROR])
        except ProjectUnknownException as e:
            logger.error(e)
            return response(e.code, e.message or
                            ResponseCodeExplain[ResponseCode.SYSTEM_ERROR])
        except Exception as e:
            logger.exception(e)
            return response(ResponseCode.FAILED)
    return wrapper
```


(End)