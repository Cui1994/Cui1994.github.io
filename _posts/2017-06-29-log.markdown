---
layout: post
category: "工作"
title:  "为Spring Boot添加日志模块"
tags: [spring boot, java]
---

# 概述
SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。

Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。

默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。

# 配置

## 添加依赖

一般来说需要添加spring-boot-starter-logging：

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-logging</artifactId>
</dependency>
```

实际开发并不需要直接添加依赖，spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

## 自定义日志配置

添加好依赖后原则上讲就可以开始使用日志模块了，但使用的是Spring Boot提供的很多默认配置，在`application.properties`中也只能修改部分属性，往往不能满足需求，因此需要自行定制配置文件实现日志配置。

Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项。

在`src/main/resources`路径下添加`logback-spring.xml`作为日志配置文件：
```
<?xml version="1.0" encoding="UTF-8"?>
<configuration  scan="true" scanPeriod="60 seconds" debug="false">
    <contextName>logback</contextName>
    <property name="log.path" value="C:\\Users\\cuijintao\\logback.log" />
    <!--输出到控制台-->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!--输出到文件-->
    <appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log</fileNamePattern>
            <maxHistory>20</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="console" />
        <appender-ref ref="file" />
    </root>

    <!-- logback为java中的包 -->
    <logger name="com.example.demo"/>
    <!--logback.LogbackDemo：类的全路径 -->
    <logger name="com.example.hello" level="WARN" additivity="false">
        <appender-ref ref="file"/>
    </logger>
</configuration>
```

### 根节点`<configuration>`属性

+ scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
+ scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。
+ debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。

#### 属性1 - 上下文名称`<contextName>`:
每个logger都关联到logger上下文，默认上下文名称为“default”。
之后可以通过%contextName来打印日志上下文名称。
```
<contextName>logback</contextName>
```

#### 属性2 - 属性变量`<property>`
定义一个key-value键值对
通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。
```
 <property name="log.path" value="C:\\Users\\cuijintao\\logback.log" />
```

#### 子节点1 - `<appender>`
appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。

`<encoder>`表示对日志进行编码：
+ `%d{HH: mm:ss.SSS}` : 日志输出时间
+ `%thread` : 日志输出进程名字
+ `%-5level`: 日志级别 TRACE < DEBUG < INFO < WARN < ERROR < FATAL
+ `%logger{36}` : 日志输出者名字
+ `%msg`: 日志消息
+ `%n`:　平台换行符

输出到文件时，RollingFileAppender用于切分文件日志：
```
    <!--输出到文件-->
    <appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>C:\\Users\\cuijintao\\logback.%d{yyyy-MM-dd_HH-mm}.log</fileNamePattern>
            <maxHistory>20</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
```

+ `<fileNamePattern>`: 指定日志的切分方式
+ `<maxHistory>`: 指定保留的切分文件的个数
+ `<totalSizeCap>`: 指定日志文件的上限大小，超过此值将会被删除

#### 子节点2 - `<root>`
必选节点，用来指定最基础的日志输出级别，只有一个level属性。
默认值为DEBUG.
```
<root level="debug">
  <appender-ref ref="console" />
  <appender-ref ref="file" />
</root>
```

#### 子节点3 - `<loger>`
`<loger>`用来设置某一个包或者具体的某一个类的日志打印级别、以及指定`<appender>`。
仅有一个name属性，一个可选的level和一个可选的addtivity属性。

+ `name`: 用来指定受此loger约束的某一个包或者具体的某一个类。
+ `level`: 日志级别
+ `addtivity`: 是否向上级loger传递打印信息。默认是true。

#### 多环境日志输出
据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：

```
<!-- 测试环境+开发环境. 多个使用逗号隔开. -->
<springProfile name="test,dev">
    <logger name="com.dudu.controller" level="info" />
</springProfile>
<!-- 生产环境. -->
<springProfile name="prod">
    <logger name="com.dudu.controller" level="ERROR" />
</springProfile>
```

在启动或打包服务是配置profile参数即可。
如启动时指定prod的方式为：
```
java -jar xxx.jar --spring.profiles.active=prod
```

# demo
这里启动一个hello world的spring-boot模板来测试日志配置。
```
package com.example.demo.com.example.demo.hello;

import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class HelloController {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @RequestMapping("/hello")
    public String index() {

        logger.info("日志测试 info");
        logger.debug("日志测试 debug");

        return "Hello World";
    }

}
```
根据上面的配置，日志文件中只记录了INFO级别的日志，每分钟对日志文件进行了切分。

