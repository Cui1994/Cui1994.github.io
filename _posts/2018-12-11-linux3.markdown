---
layout: post
category: "Linux"
title:  "Linux基础（三）进程"
tags: [Linux, 读书笔记]
---

* content
{:toc}

![](https://i.loli.net/2018/12/12/5c110d5c1ea0c.jpeg)

> 该系列文章为《Linux/Unix系统编程手册》的学习笔记，由于该书太过冗长，属于工具书的类别，这里对书中的一些核心内容加以提炼和整理。
> 书中的编程练习这里不做展示和说明。




## 概念

**进程**是可执行程序的一个实例，由一系列用户控件和内核数据结构组成。

**进程号**: 由内核维护的进程标识，是一个正整数，init进程号永远为1，其余进程号与进程无绑定关系。

>进程号有最大值，储存在`/proc/sys/kernel/pid_max`文件中，32位机最大值为32767。


## 进程内存布局
### 虚拟内存管理

计算机为每个进程维护了一片连续的、私有的地址空间，让进城有了独享内存的错觉。CPU获取内存时，通过**内存管理单元(MMU)**进行虚拟寻址，将虚拟地址翻译成物理地址。

虚拟内存将其地址空间划分为大小固定的**虚拟页**，每个虚拟页的大小为2的n次方字节。同样的，物理内存也被划分为大小相同的**物理页**。

### 页表

为了支持虚拟内存。内核为每个进程维护一张页表，页表结构如下图。

![](https://i.loli.net/2018/12/12/5c0fe2312e1d6.png)

页表是一个**页表条目(PTE)**的数组，每个页表条目由一个**有效位**和一个n位**地址字段**组成。

- 如果有效位为1，表示虚拟页被缓存在物理页中，后面的地址字段指向物理页的地址。
- 如果有效位为0，若地址字段为null，则表明该虚拟页尚未被使用，否则，地址字段的地址指向磁盘中的地址，表示虚拟页未被缓存。

在CPU进行虚拟寻址时会发生下面两种情况：

- **页命中**: 虚拟页的有效位为1，直接从地址字段指向的物理页中读取数据。
- **缺页**: 虚拟页的有效位为0，这时将触发`缺页异常`，内核中的缺页异常处理程序将选择一个物理页为牺牲页，读出地址字段指向的磁盘空间读取数据，并缓存在牺牲页的地址中。

### 进程内存结构

进程分配的内存有很多部分，用**段**来表示虚拟内存的逻辑划分，包括文本段、数据段、栈和堆，布局如下图：

![](https://i.loli.net/2018/12/12/5c0fe77321912.png)

需要注意的是，栈的内存是从上向下增长的，而堆的内存是从下向上增长的。

## 进程行为

### 创建
```c
pid_t fork(void);
```
调用`fork`后会出现两个进程，都会从`fork`的返回处开始执行。不同的是父进程返回子进程的进程号，而子进程返回0。

- 子进程共享父进程程序的文本段。
- 子进程将完全复制父进程的栈段、数据段及堆段，修改这些段中的变量不会影响父进程。
- 子进程将获取父进程的所有文件描述符副本，行为类似于`dup`，即**父子进程对应的文件描述符均指向相同的打开文件句柄**。

### 终止
```c
void _exit(int status);
```

调用`_exit(status)`系统调用终止当前进程，并以参数`status`的值作为终止状态，可以供父进程`wait`获取，`0`为正常退出。

经常通过调用库函数`exit(status)`来终止进程，它会执行以下动作：

- 调用退出处理程序
- 刷新stdio流缓冲区(fflush)
- 执行`_exit`系统调用

注意：stdio流缓冲区是维护在用户空间内存中的，因此创建子进程时也会复制缓冲区。如果不希望子进程获取父进程的缓存，需要在`fork`调用前执行`fflush`刷新缓冲区。

### 等待子进程终止
```c
pid_t wait(int *status);
```
调用`wait`来等待子进程终止，并以子进程`pid`作为调用返回值。如果调用`wait`前没有任何子进程终止，进程将被block直到任意子进程终止。
```c
pid_t waitpid(pid_t pid, int *status, int options);
```
调用`waitpid`等待指定子进程终止，`options`参数设置为`WNOHANG`，如果子进程状态为发生变化，父进程不会被block，而是直接返回0。`waitpid(-1)`相当于`wait`。

父子进程生命周期不同将产生两种进程：
- **孤儿进程**: 父进程先于子进程终止，子进程变为孤儿进程，`init`将接管所有的孤儿进程成为其父进程。
- **僵尸进程**: 子进程先于父进程终止，父进程未调用`wait`，内核将子进程转变为僵尸进程，父进程调用`wait`后内核会将僵尸进程删除，如果父进程未调用`wait`而直接终止，`init`进程将接管子进程并直接调用`wait`。

### 执行新程序
```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
```
调用`execve`将制定路径的程序加载到当前进程的内存空间，进程的栈、数据、堆段将被新程序的相应部件替换，但**进程中打开的文件描述符依然有效**。

若想在调用`exec`函数后关闭文件描述符，需对文件描述符设置`close-on-exec`标识。
```c
int system(const char *command);
```
调用`system`函数来执行shell命令。`system`调用后至少会再创建两个新进程，一个运行shell，另一个用于shell执行的命令。


## SIGCHILD信号

子进程在终止时会向父进程发送SIGCHILD信号，父进程管理子进程的方式有两种：

- 在SIGCHILD信号处理函数中循环以`WNOHANG`标识符调用`waitpid(-1)`，确保在此期间所有的已终止子进程被删除。
- 将SIGCHILD信号处置显式设置为`SIG_IGN`，虽然对SIGCHILD的默认处置就是忽略，但显式设置`SIG_IGN`后，子进程终止后会直接被内核删除，不用转化为僵尸进程。

(End)

